# vim:filetype=sh:
declare -r TRUE=1
declare -r FALSE=0

declare -r LEFT_SIDE=0
declare -r RIGHT_SIDE=1

declare -r strongQuote="'"
declare -r weakQuote='"'
declare -r eitherQuote=$strongQuote$weakQuote

# Define the markup flags that describe token types, metadata, and data types.
declare -A tt
tt=(
    [FUNCTION_ARITY]='A'
    [BOOLEAN]='B'
    [BLOB]='b'
    [COMPARATOR]='C'
    [DATE]='D'
    [DATE_RANGE]='d'
    [FORCED_EXPANSION]='E'    # An expandable word that the user has marked with the variable indicator
    [FUNCTION]='F'    [EXPANDED_FUNCTION]='f'    # EXPANDEDs must be the lowercase of their partners
    [DECIMAL]='g'     [FLOAT]='g' # Let DECIMAL and FLOAT be synonyms
    [INTEGER]='I'
    [INT_RANGE]='i'
    [FLOAT_LIST]='L'
    [INT_LIST]='l'
    [NUMERIC]='N'
    [BEGIN_NCV]='n'
    [OPERATOR]='O'
    [PREFIX_LIST]='P'
    [REGEX_LIST]='R'
    [SPACE]='S'             # distinguishes cosmetic spaces from spaces inside other tokens
    [TIME]='T'
    [TIMESTAMP]='t'
    [STRING_CONSTANT]='V'

    # A word that might be a string constant or an abbreviated variable name:
    [EXPANDABLE_WORD]='W'    [EXPANDED_WORD]='w'

    # A sequence of words that might be expandable according to special rules,
    # for handling special intra-query constructs such as DISTINCT and INTERVAL:
    [EXPANDABLE_SEQUENCE]='X'    [EXPANDED_SEQUENCE]='x'

    [FILENAME]='@'
    [BEGIN_GROUP]='('  [LEFT_PAREN]='('
    [END_GROUP]=')'    [RIGHT_PAREN]=')'
    [BEGIN_FUNCTION]='['
    [END_FUNCTION]=']'
    [END_NCV]='/'      [TYPE_NCV]='/'    # let the end markers / type names be synonymous
    [END_CV]='\'       [TYPE_CV]='\'
    [END_V]='|'        [TYPE_V]='|'

    [DELIMITER]=','

    [ANY_TYPE]=.
    [INVALID_TYPE]=1        # This doubles as an error code so it must be a number
)

declare -r g_expandableTypes=${tt[EXPANDABLE_WORD]}${tt[EXPANDABLE_SEQUENCE]}${tt[FUNCTION]}
declare -r g_expandedTypes=${tt[EXPANDED_WORD]}${tt[EXPANDED_SEQUENCE]}${tt[EXPANDED_FUNCTION]}

# Error/status codes
declare -ri ERR_INVALID_TYPE=${tt[INVALID_TYPE]}   # Converts ${tt[INVALID_TYPE]} to a number

########################################################################
# Simulate modifiable function arguments as in pass-by-pointer/reference.
# Implementation consists of global variables and several functions, {s,g}etReturnValues()
g_storage=""
g_storage1=""
g_storage2=""
g_storage3=""
g_storage4=""
g_storage5=""
g_storage6=""
g_storage7=""

########################################################################
# setReturnValues (value [...])
#
# Saves the arguments to global storage for retrieval upon function return.
# Meant to be invoked inside the callee immediately before returning.
########################################################################
function setReturnValues()
{
    declare -i i
    local givenValue storageCell 

    for ((i=1; i<=$#; i++)); do
        storageCell="g_storage"$i
        givenValue=${!i}
        eval $storageCell='$givenValue'
    done

    g_storage=${g_storage1}
}

function setReturnValue() { setReturnValues "$1"; }

########################################################################
# getReturnValues (name [...])
#
# Populates the variables named by the arguments with the values in global storage.
# Meant to be invoked inside a caller immediately after return from a callee.
#
# N.B. The arguments must be variable names passed as flat strings,
#      not the corresponding values (accidentally) referenced by the names
########################################################################
function getReturnValues()
{
    declare -i i
    local givenVariable value storageCell

    if [[ -z $g_storage ]]; then
        g_storage=${g_storage1}
    fi

    for ((i=1; i<=$#; i++)); do
        givenVariable=${!i}
        storageCell="g_storage"$i
        value=${!storageCell}
        eval $givenVariable='$value'
    done
}

function getReturnValue() { getReturnValues "$1"; }

########################################################################
# appendReturnValue( variableName )
# APPENDS the first/only return value to the variable having the given name
########################################################################
function appendReturnValue() 
{
    local givenVariable=${!1}
    eval $givenVariable+='$g_storage'
}

