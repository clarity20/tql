# vim:filetype=sh:
declare -r TRUE=1
declare -r FALSE=0

declare -r LEFT_SIDE=0
declare -r RIGHT_SIDE=1

declare -r NULL_INDICATOR="-"
declare -r PREPARED_STMT_PARM="?"

declare -r strongQuote="'"
declare -r weakQuote='"'
declare -r eitherQuote=$strongQuote$weakQuote

# The reference data descriptions used to expand abbreviated table or column names
g_masterTableList=""
g_masterColumnList=""

# Storage for configuration settings loaded upon startup
declare -A g_config

# The possible types of configurable regexes
declare -A rgx
rgx=(
    [NORMAL]=0
    [DEFAULT_DATE]=1
    [DEFAULT_INT]=2
    [DEFAULT_FLOAT]=3
    [DEFAULT_ALPHA]=4
    [DELETED]=9
)

# Define the markup flags that describe token types, metadata, and data types.
declare -A tt
tt=(
    [FUNCTION_ARITY]='A'
    [BOOLEAN]='B'
    [BLOB]='b'
    [COMPARATOR]='C'
    [DATE]='D'
    [DATE_RANGE]='d'
    [FORCED_EXPANSION]='E'    # An expandable word that the user has marked with the variable indicator
    [FUNCTION]='F'    [EXPANDED_FUNCTION]='f'    # EXPANDEDs must be the lowercase of their partners
    [DECIMAL]='g'     [FLOAT]='g' # Let DECIMAL and FLOAT be synonyms
    [INTEGER]='I'
    [INT_RANGE]='i'
    [FLOAT_LIST]='L'
    [INT_LIST]='l'
    [NUMERIC]='N'
    [BEGIN_NCV]='n'
    [OPERATOR]='O'
    [PREFIX_LIST]='P'
    [ALNUM_REGEX]='r'
    [REGEX_LIST]='R'
    [ALNUM_LIST]='s'
    [SPACE]='S'             # distinguishes cosmetic spaces from spaces inside other tokens
    [TIME]='T'
    [TIMESTAMP]='t'
    [STRING_CONSTANT]='V'

    # A word that might be a string constant or an abbreviated variable name:
    [EXPANDABLE_WORD]='W'    [EXPANDED_WORD]='w'

    # A sequence of words that might be expandable according to special rules,
    # for handling special intra-query constructs such as DISTINCT and INTERVAL:
    [EXPANDABLE_SEQUENCE]='X'    [EXPANDED_SEQUENCE]='x'

    [FILENAME]='@'
    [BEGIN_GROUP]='('  [LEFT_PAREN]='('
    [END_GROUP]=')'    [RIGHT_PAREN]=')'
    [BEGIN_FUNCTION]='['
    [END_FUNCTION]=']'
    [END_NCV]='/'      [TYPE_NCV]='/'    # let the end markers / type names be synonymous
    [END_CV]='_'       [TYPE_CV]='_'
    [END_V]='|'        [TYPE_V]='|'

    [DELIMITER]=','

    [NATIVE_TYPE]='-'  # A token that can take on any native SQL type, depending on context
                       # Examples of this are NULL and '?'
    [INVALID_TYPE]=1   # This doubles as an error code so it must be a number
)

declare -r g_expandableTypes=${tt[EXPANDABLE_WORD]}${tt[EXPANDABLE_SEQUENCE]}${tt[FUNCTION]}
declare -r g_expandedTypes=${tt[EXPANDED_WORD]}${tt[EXPANDED_SEQUENCE]}${tt[EXPANDED_FUNCTION]}
declare -r g_ncvTypeMarkers=${tt[END_NCV]}${tt[END_CV]}${tt[END_V]}

########################################################################
# query types
########################################################################
declare -A qt
qt=(
    [SELECT]=0
    [UPDATE]=1
    [INSERT]=2
    [DELETE]=3
)

########################################################################
# Error/exception handling via return codes and error messages
# NB: Since the shell limits return codes to [0,255] we might need
# to define additional collections of return codes. Just be careful about
# the duplicate meanings that certain numeric code values would have.
########################################################################
declare -A rc
rc=(
    [SUCCESS]=0
    [INVALID_TYPE]=1
    [INFEASIBLE_EXPR]=2
    [INVOCATION_SYNTAX]=3
    [EMPTY_RESULT_SET]=4
    [ILL_FORMED_CONFIG_FILE]=5
)
declare -a eMsg
eMsg=(
    ""
    "Invalid type for expression '\$expression'"
    "Illegal grammar / no feasible interpretation for '\$expression'."
    "First non-option argument must be a table name."
    "No results returned."
    "Attribute '\$attribute' not allowed in regex section of config file."
)

declare -i g_returnCode=${rc[SUCCESS]}
g_statusMsg=""
g_errorStream=/dev/stderr

###########
# setError (returnCode [, errMsg] )
# Sets the internal error code and error message
# errMsg defaults to the hard-coded message in array "rc" above
###########
function setError()
{
    g_returnCode=$1
    local message=${eMsg[$1]}
    eval g_statusMsg=\"$message\"

    # Allow the second argument to override the default message
    if [[ -n $2 ]]; then
        eval g_statusMsg=\"$2\"
    fi

    return $g_returnCode
}

###########
# doExit [message]
# Exits the program with the current return code, dumping the current message
# (if any) to the current error stream
###########
function doExit()
{
    echo $g_statusMsg "$1" >> $g_errorStream
    exit $g_returnCode
}

########################################################################
# Simulate modifiable function arguments as in pass-by-pointer/reference.
# The implementation consists of a collection of global variables and
# several functions which are their sole direct manipulators
########################################################################
g_storage=""
g_storage1=""
g_storage2=""
g_storage3=""
g_storage4=""
g_storage5=""
g_storage6=""
g_storage7=""

########################################################################
# setReturnValues (value [...])
#
# Saves the arguments to global storage for retrieval upon function return.
# Meant to be invoked inside the callee immediately before returning.
########################################################################
function setReturnValues()
{
    declare -i _i
    local _givenValue _storageCell

    for ((_i=1; _i<=$#; _i++)); do
        _storageCell="g_storage"$_i
        _givenValue=${!_i}
        eval $_storageCell='$_givenValue'
    done

    g_storage=${g_storage1}
}

function setReturnValue() { setReturnValues "$1"; }

########################################################################
# getReturnValues (name [...])
#
# Populates the variables named by the arguments with the values in global storage.
# Meant to be invoked inside a caller immediately after return from a callee.
#
# N.B. The arguments must be variable names passed as flat strings,
#      not the corresponding values (accidentally) referenced by the names
########################################################################
function getReturnValues()
{
    declare -i _i
    local _givenVariable _value _storageCell

    if [[ -z $g_storage ]]; then
        g_storage=${g_storage1}
    fi

    for ((_i=1; _i<=$#; _i++)); do
        _givenVariable=${!_i}
        _storageCell="g_storage"$_i
        _value=${!_storageCell}
        eval $_givenVariable='$_value'
    done
}

function getReturnValue() { getReturnValues "$1"; }

########################################################################
# appendReturnValue( variableName )
# APPENDS the first/only return value to the variable having the given name
########################################################################
function appendReturnValue() 
{
    declare -i _i=1
    local _givenVariable=${!_i}
    eval $_givenVariable+='$g_storage'
}

