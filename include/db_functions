# vim: set filetype=sh:

# Set some essential variables
: ${BASHFUNC_HOME:=$HOME}
: ${TQL_HOME:=$HOME/tql}
: ${TQL_SCHEMA_CACHE:=$TQL_HOME/cache}
: ${TQL_CONFIG_DIR:=$TQL_HOME/config}
# Override the PATH with the locations of this project installation and your GNU/Linux coreutils
# TODO Clarify which versions of which utilities are required. Verify POSIX compatibility.
PATH=$TQL_HOME:$BASHFUNC_HOME/bin:/usr/local/bin:/usr/bin

# Enable extended file globbing. This allows us to write shorter, simpler code in a few places.
shopt -s extglob

# Load the universal TQL constants
if ((g_sourcedGlobals!=1)); then
    source $TQL_INCLUDE/tql_globals
    g_sourcedGlobals=1
fi

# TODO Phase this out; bring isArgOfType into the main code
source $TQL_INCLUDE/script_functions

source $TQL_INCLUDE/expand_functions

# TODO Consider introducing some variable naming conventions for better readability
# and to minimize shadowing bugs.
# (1) Use the prefix g_ to mean "global".
# (2) Use the form "_varName_funcAbbr" for variables local to the indicated function
#     and everything lower in the call stack, and used in both.

declare -r delim=$'\n'
declare -r delim2=$'\f'
declare -r ILLEGAL_DEFAULT_ALPHA=illegalDefaultAlpha
declare -r ILLEGAL_DEFAULT_NUM=illegalDefaultNum
declare -r placeholderForEmpty=" "
declare -r defaultAction=SELECT
declare -r setClauseMarker="@"
declare -r updateOperator=':='
declare -r MIN_VALUE_LEN=1       # min/max length of values supplied on the command line
declare -r MAX_VALUE_LEN=1024

# Assign defaults for values used in many caller scripts
g_defaultNums=$ILLEGAL_DEFAULT_NUM
g_defaultNumCodes=0i
g_defaultAlnums=$ILLEGAL_DEFAULT_ALPHA
g_defaultAlnumCodes=qa
g_ACTION=$defaultAction
# Enable a warning message when a query would return the full table. Intended for large tables.
g_warnOnSelectAll=$TRUE

g_dbClientOptions=""
g_mainConjunction=AND
g_haveParser=$FALSE

##############################################################################################
# getQueryType
##############################################################################################
function getQueryType()
{
    isOptionOn u $OPTIONS
    if (($? == $TRUE)); then
        return ${qt[UPDATE]}
    else
        return ${qt[SELECT]}
    fi
}

##############################################################################################
# formQuery (queryType, actionClause, whereClause, limitClause)
# Assembles a full query from its pieces based on the query type
##############################################################################################
function formQuery()
{
    declare -i queryType=$1
    local actionClause=$2 whereClause=$3 limit=$4
    local fullQuery

    local tables=${g_config[mainTable]}
    if [[ -n ${g_config[supportingTables]} ]]; then
        tables+=",${g_config[supportingTables]}"
    fi

    case $queryType in
        ${qt[UPDATE]})
            fullQuery="UPDATE $tables $actionClause $whereClause $limit"
            ;;
        ${qt[DELETE]})
            fullQuery="DELETE FROM $tables $whereClause $limit"
            ;;
        ${qt[SELECT]})
            fullQuery="SELECT $actionClause FROM $tables $whereClause $limit"
            ;;
    esac

    setReturnValue "$fullQuery"
    return ${rc[SUCCESS]}
}

##############################################################################################
# parseCompletely  <full command line>
# Wrapper for the argument parsing and clause generation engines
# Return code: 0 for select queries, 1 for updates, 10 or greater for errors
##############################################################################################
function parseCompletely()
{
    # Constant ("enumerated") internal error codes
    declare -r retCode_noSelection=0
    declare -r retCode_selectMainColumnOnly=1
    declare -r retCode_clearAllSelections=2
    declare -r retCode_ordinarySelection=3

    local remainingArgs

    # Filter the command-line options into a separate list
    parseOutOptions "$@"
    if (($?)); then
        getReturnValues OPTIONS remainingArgs
        eval set -- $remainingArgs
    fi

    # Load the expression parser
    if [[ $g_haveParser == $FALSE ]]; then
        g_haveParser=$TRUE
        source $TQL_INCLUDE/parse_functions
    fi

    # If the UPDATE option is active, prepare the SET clause
    declare -i queryType
    getQueryType; queryType=$?
    if ((queryType == ${qt[UPDATE]})); then
        parseOutSets "$@"
        if (($?)); then
            getReturnValues SET_CLAUSE setAbbrs remainingArgs
            eval set -- $remainingArgs
        else
            echo Error: The UPDATE flag is set without any UPDATE instructions.
            return 15
        fi
    elif [[ "$@" =~ $updateOperator ]]; then
        echo Error: An UPDATE instruction was detected but the update flag was not set.
        return 16
    fi

    # Extract the column selection modifiers from the command line
    parseOutSelects "$@"
    retVal=$?
    if ((retVal)); then  # some SELECT-type arguments were detected

        # Reject a mixing of query types
        if [[ $queryType != ${qt[SELECT]} ]]; then
            echo Error: Both SELECT and UPDATE commands were detected.
            return 17
        fi

        # Parse out the returned values
        getReturnValues rawPreselects rawPostselects remainingArgs
        eval set -- $remainingArgs
        if [[ $rawPreselects == " " ]]; then rawPreselects=; fi     ## old way was to use backticks so " " became ""
        if [[ $rawPostselects == " " ]]; then rawPostselects=; fi
    fi

    # If required, make special adjustments to the standard column set
    case $retVal in
        $retCode_clearAllSelections)   g_config[standardColumns]="" ;;
        $retCode_selectMainColumnOnly) g_config[standardColumns]=${g_config[primaryColumn]} ;;
        *) isOptionOn selectAll $OPTIONS
           if (($?)); then
               g_config[standardColumns]="*"
           fi ;;
    esac

    # Pass any special options to the db client
    g_dbClientOptions=""
    isOptionOn noHeader $OPTIONS
    if (($?)); then g_dbClientOptions+="-N "; fi

    # Expand the abbreviated names unless directed otherwise
    isOptionOn "dontExpand" $OPTIONS
    if (($?)); then
        # Assemble the full SELECT clause from the three parts without expanding
        assembleSelectClause "$rawPreselects" "${g_config[standardColumns]}" "$rawPostselects"
        getReturnValue ACTION_CLAUSE

    else
        if [[ $queryType == ${qt[UPDATE]} ]]; then
            # Expand the SET clause column names and finish off the clause itself
#MMMM Address the side effect of reworking expand():
            expandColumnNames "${g_config[mainTable]}" "$setAbbrs"
            getReturnValue setCols setCodes
            OLDFS="$IFS"; IFS=$',' expandedSetCols=(${setCols})

            local nullPlaceholder=$setClauseMarker$NULL_INDICATOR$setClauseMarker
            for nextColumn in ${expandedSetCols[@]}; do
                nextAbbr=${setAbbrs%%,*}; nextCode=${setCodes%%,*}

                # If it's a null marker, put "NULL" in its place
                if [[ "$SET_CLAUSE" =~ ^[^$setClauseMarker]*$nullPlaceholder ]]; then
                    SET_CLAUSE=${SET_CLAUSE/$nullPlaceholder/NULL}

                # Else quote the value if necessary
                elif [[ $nextCode =~ ^q ]]; then
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/\'}
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/\'}

                # Else remove the markers from the value
                else
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/}
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/}
                fi

                SET_CLAUSE=${SET_CLAUSE/$nextAbbr/$nextColumn}
                setAbbrs=${setAbbrs#$nextAbbr,}; setCodes=${setCodes#$nextCode,}
            done
            IFS="$OLDFS"
            SET_CLAUSE="SET "$SET_CLAUSE

        else
            # Expand the SELECT clause column names, keeping track of the pre/post distinction
            expandSelections "$rawPreselects"; getReturnValue preselects
            expandSelections "$rawPostselects"; getReturnValue postselects

            # Assemble the full SELECT clause from the three parts
            assembleSelectClause "$preselects" "${g_config[standardColumns]}" "$postselects"
            getReturnValue ACTION_CLAUSE
        fi
    fi

    if [[ $queryType == ${qt[SELECT]} ]]; then
        # Check for empty SELECT clause. (Should only be possible if "00" option is invoked.)
        if [[ ! "$ACTION_CLAUSE" =~ [[:alnum:]*] ]]; then
            echo ERROR: Your column selection is empty. Please select some columns. > $g_errorStream
            return 10
        fi
    fi

    # Build the core WHERE-clause by lexing, parsing and expanding the arguments and translating to SQL.
    generateWhereClause "$@" || return $?
    getReturnValues WHERE_CLAUSE sortInstructions

    # Massage the query contents based on the user options
    # -- By default, use NULLs "intuitively" inside NOT-subclauses rather than using SQL's built-in 3-valued-logic
    isOptionOn "trueNull|tn" $OPTIONS
    if (($? == 0)); then
        if [[ "$WHERE_CLAUSE" =~ NOT ]]; then
            useIntuitiveNulls "$WHERE_CLAUSE"
            getReturnValue WHERE_CLAUSE
        fi
    fi

    # Complete the WHERE clause:
    # 1. Add any pre/postclause material
    local pre=${g_config[wherePreclause]}
    if [[ -n $pre ]]; then pre+=" "; fi
    local post=${g_config[wherePostclause]}
    WHERE_CLAUSE=$pre$WHERE_CLAUSE
    if [[ -n $WHERE_CLAUSE && -n $post ]] ; then
        post=" AND $post"
    fi
    WHERE_CLAUSE+=$post
    # 2. Make the WHERE clause start with "WHERE", except for empty clauses
    if [[ $WHERE_CLAUSE =~ ^($g_mainConjunction)?(.+) ]]; then
        WHERE_CLAUSE="WHERE ${BASH_REMATCH[2]}"
    fi

    if [[ "$WHERE_CLAUSE" =~ illegalDefault ]]; then
        if [[ "$WHERE_CLAUSE" =~ $ILLEGAL_DEFAULT_ALPHA ]]; then
            echo FAIL: Cannot infer a column name for pure alphabetic or regex arguments.
        elif [[ "$WHERE_CLAUSE" =~ $ILLEGAL_DEFAULT_NUM ]]; then
            echo FAIL: Cannot infer a column name for pure numeric arguments.
        fi
        return 13
    fi

    # Construct the LIMIT clause
    isOptionOn "l[0-9]+" "$OPTIONS" -show; getReturnValue LIMIT_CLAUSE
    if [[ -n "$LIMIT_CLAUSE" ]]; then
        LIMIT_CLAUSE="LIMIT "${LIMIT_CLAUSE#[Ll]}
    fi
    : ${LIMIT_CLAUSE:=$placeholderForEmpty}

    # If the WHERE clause is effectively empty, provide a warning before returning an unrestricted result set
    if [[ ( -z "$WHERE_CLAUSE" ) && ( ! $LIMIT_CLAUSE =~ [1-9] ) && ( ! $ACTION_CLAUSE =~ "count(*)" ) && ( $g_warnOnSelectAll == $TRUE ) ]]; then
        echo WARNING: Query is unrestricted, every record will be returned! > $g_errorStream
        read -n1 -p "Continue (y/n)? " doContinue > $g_errorStream
        echo > $g_errorStream
        if [[ ! $doContinue =~ ^[Yy]$ ]]; then
            echo Query cancelled.
            return 14
        fi
    fi

    setReturnValues "$OPTIONS" "${SET_CLAUSE:-$ACTION_CLAUSE}" "$WHERE_CLAUSE" "$LIMIT_CLAUSE" "$sortInstructions" $queryType

    return ${rc[SUCCESS]}
}

####################################################################################
# assembleSelectClause  <prefix>  <infix>  <suffix>
#
# Assembles the select clause from the three parts provided,
# inserting commas only where appropriate
####################################################################################
function assembleSelectClause()
{
    local selectClause
    local preselects=$1
    local standardColumns=$2
    local postselects=$3

    selectClause=$preselects
    if [[ -n $selectClause && -n $standardColumns ]]; then
        selectClause+=,
    fi
    selectClause+=$standardColumns
    if [[ -n $selectClause && -n $postselects ]]; then
        selectClause+=,
    fi
    selectClause+=$postselects

#MMMM Temp fix: strip out all of the markup tags, leaving a pure SELECT clause
#MMMM This means the delims, token counts and type indicators. (But for pred delims there are no counts.)
    selectClause=${selectClause//$tokenDelimiter?/}

    setReturnValue "$selectClause"
}

####################################################################################
# expandSelections  <list of selections>
#
# Expands a delimited list of SELECT expressions.
####################################################################################
function expandSelections()
{
    local rawSelections=$1

    local selectionDelimiter=$tokenDelimiter${tt[DELIMITER]}"0" # 0 assumes the delimiters have no enclosing parens
    local tokenizedSelections completeExpansion currentSelection expandedSelection

    # Tokenize the (comma-delimited) list of selections
    parseQueryClause "$rawSelections" || return $?
    getReturnValue tokenizedSelections

    # Handle the selections one-by-one. Each can contain one or more expandable words.
    completeExpansion=""
    while [[ -n $tokenizedSelections ]]; do

        # Pull the next selection from the selection list
        if [[ $tokenizedSelections =~ $selectionDelimiter(.*) ]]; then
            currentSelection=${tokenizedSelections%${BASH_REMATCH[0]}}
            tokenizedSelections=${BASH_REMATCH[1]}
        else
            currentSelection=$tokenizedSelections
            tokenizedSelections=""
        fi

        # Cycle through the abbreviated words within the current selection
        # to construct a new selection in which all words have been expanded
        #TODO We will eventually modify this loop to accumulate the lists of expansion candidates
        #TODO before we prune them down through semantic analysis of the parse tree.
        #TODO Right now, we are rolling out the architecture that enables us to accumulate them.
        expandedSelection=""
        local tokenPrefix expansionType currentAbbr unexpandablePrefix
        while [[ $currentSelection =~ ($tokenDelimiter[0-9]+)([$g_expandableTypes])([^$tokenDelimiter]+)(${tokenDelimiter}.*|$) ]]; do
            tokenPrefix=${BASH_REMATCH[1]}
            expansionType=${BASH_REMATCH[2]}
            currentAbbr=${BASH_REMATCH[3]}
            unexpandablePrefix=${currentSelection%${BASH_REMATCH[0]}}
            currentSelection=${BASH_REMATCH[4]}

            case $expansionType in
                ${tt[EXPANDABLE_WORD]})
                    getExpandedColumnNames "$TABLE_NAMES" $currentAbbr; getReturnValue expansionCandidates
                    promptForExpansion "$currentAbbr" "$expansionCandidates"
                    getReturnValues expandedName internalType
                    ;;
                ${tt[EXPANDABLE_SEQUENCE]})
#MMMM Needs finishing:
                    expandSequence "$currentAbbr"
                    getReturnValue expandedName
                    ;;
                ${tt[FUNCTION]})
#MMMM Needs finishing:
                    getExpandedFunctionNames "$TABLE_NAMES" $currentAbbr; getReturnValue expansionCandidates
                    promptForExpansion "$currentAbbr" "$expansionCandidates"
                    getReturnValues expandedName internalType
                    #MMMM finalizeExpandedFunctionName $expandedName
                    ;;
            esac

            # Piece together the expanded string
            expandedSelection+=$unexpandablePrefix$tokenPrefix$expansionType$expandedName
        done

        # The selection is fully expanded. If there is a trailing literal piece, attach it
        if [[ -n $currentSelection ]]; then
            expandedSelection+=$currentSelection
        fi
        completeExpansion+=$expandedSelection,
    done
    completeExpansion=${completeExpansion%,}

    setReturnValue "$completeExpansion"
}


####################################################################################
# useIntuitiveNulls
# Alters a fully-constructed WHERE clause so as to imitate a user-friendly 2-valued logic
# in place of SQL's 3-valued logic; IOW, allows NULL values to pass not-equal checks against
# non-NULL values. If the "trueNull" option is set, the caller AVOIDs this function.
####################################################################################
function useIntuitiveNulls()
{
    # Divide the given WHERE clause at the "NOT (" if it exists
    local lhs="${1%%NOT (*}"
    local rhs="${1#$lhs}"

    # Walk the given WHERE-clause for NOT-subclauses we need to change
    while [[ $rhs =~ ^NOT\  ]]; do

        # The first goal is to correctly and exactly identify the next NOT subclause.
        # We are working with three forms of NOT subclause,
        #     (1) NOT (x1 = value    [OR ... OR    xn = value] [ OR x1...xn IS NULL])
        #     (2) NOT (x1 LIKE 'rgx' [OR ... OR xn LIKE 'rgx'] [ OR x1...xn IS NULL])
        #     (3) NOT (x1 IN (list)  [OR ... OR  xn IN (list)] [ OR x1...xn IS NULL])
        # since we only introduce NOT when negating the comparator. The checks for NULL
        # will appear iff the user explicitly included NULLs in his input argument.

        # Find the ")" character that closes the NOT clause.
        # Advance to the first ')'
        [[ $rhs =~ ^([^\)]+\))(.*) ]]
        local notClause=${BASH_REMATCH[1]}
        # If there is a second '(' before that...
        if [[ $notClause =~ \(.*\( ]]; then
            # ... then find the first two ')'s without an intervening '('
            [[ $rhs =~ \)[^\(]*\)(.*) ]]
            # The NOT clause consists of everything up to and including this
            notClause=${rhs%%${BASH_REMATCH[1]}}
        fi

        # Skip this NOT clause if it already takes "nullness" into account
        if [[ $notClause =~ NULL ]]; then
            lhs+=$notClause         # increase
            rhs=${rhs#$notClause}   # shrink

        # Update the NOT clause by allowing NULLs as appropriate.
        else
            # If there are no NULLs, the user did not explicitly give them. In keeping with
            # two-valued logic, since we have negated the clause we need to make explicit
            # allowance for NULL values. So we will render the 2-valued-logical
            #    NOT ( a OR b OR ... )
            # as the following in SQL:
            #    NOT ( a OR b OR ... ) OR a IS NULL OR b IS NULL OR ...

            local originalNotClause=$notClause

            # Parse out the first column name
            [[ $notClause =~ \(\ ([^ ]*) ]]
            firstColumnName="${BASH_REMATCH[1]}"

            # Is the NOT clause a compound clause?
            if [[ $notClause =~ \ OR\  ]]; then

                # Parse out the last column name
                [[ $notClause =~ ([^ ]*)\ (LIKE|IN|=)\ [^\ ]*$ ]]
                lastColumnName="${BASH_REMATCH[1]}"

#MMMM TODO PYTHON:
#A better way to retrieve "columnList" is to query it here after having stored it in
#the most basic way at the time the SQL was constructed
                local columnList
                if [[ $firstColumnName == $lastColumnName ]]; then
                    columnList=$firstColumnName
                elif [[ $g_defaultAlnums =~ $firstColumnName.*$lastColumnName ]]; then
                    columnList=$g_defaultAlnums
                else
                    columnList=$g_defaultNums
                fi

                # Make the key addition(s) to the NOT-subclause
                OLDFS="$IFS"; IFS=$','
                for columnName in $columnList; do
                    $notClause+=" OR ${columnName%%:*} IS NULL"       # chop off any special indicators appended to the columnName
                done
                IFS="$OLDFS"

            # Otherwise the NOT subclause is a simple clause and we have only one column name
            else
                notClause+=" OR "$firstColumnName" IS NULL"
            fi

            # Update lhs/rhs for the next iteration: substitute in the modified NOT subclause
            # and advance to the next NOT subclause if there is one
            lhs+=$notClause
            rhs=${rhs#$originalNotClause}
        fi

        # When there are no more NOT clauses, finalize the string and break the loop
        if [[ ! rhs =~ ^NOT\  ]]; then
            lhs+=$rhs
            break
        fi
    done

    # End of function.
    setReturnValue "$lhs"
}

###################################################################################
# isOptionOn/Off  option  optionSet  [-show]
# Looks for the specified option(s) in the (colon-delimited and -surrounded) optionSet
###################################################################################
function isOptionOn()
{
    local regex=":($1):"

    if [[ "$2" =~ ${regex,,} ]]; then   # Lowercase-ify the regex to get case-agnosticism
        if [[ "$3" == -show ]]; then
            setReturnValue "${BASH_REMATCH[1]}"
        fi
        return 1
    else
        setReturnValue ""
        return 0
    fi
}

function isOptionOff()
{
    isOptionOn "$@"
    return $(( ! $? ))
}

function setOption()
{
    if [[ ! "$OPTIONS" =~ :${1,,}: ]]; then
        OPTIONS+=${1,,}":"
    fi

    return ${rc[SUCCESS]}
}

function clearOption()
{
    if [[ "$OPTIONS" =~ :${1,,}: ]]; then
        OPTIONS=${OPTIONS/:${1,,}/}
    fi
}


##########################################################################################
# loadConfigForTable (configFile, tableName)
# Loads the configuration settings into global memory
##########################################################################################
function loadConfigForTable()
{
    local configFile=$1 tableName=$2
    local fileText

    # Load the config file
    mapfile -t < "$configFile"

    # In two steps, trim the file down to the section for this table
    # Step 1: remove the leading content
    OLDFS=$IFS; IFS=$'\n'
    [[ "${MAPFILE[*]}" =~ (($'\n'|^)\[$tableName])(.*) ]]
    IFS=$OLDFS
    local tableSection=${BASH_REMATCH[3]}
    # Step 2: remove the trailing content, if any
    if [[ "$tableSection" =~ $'\n'\[.*$ ]]; then
    #]                 # make vim syntax highlighter happy
        if [[ "$tableSection" =~ (.*)"${BASH_REMATCH[0]}"$ ]]; then
            tableSection=${BASH_REMATCH[1]}
        fi
    fi

    declare -i regexMode=$FALSE regexCount=0
    local regexType columnType
    local attribute value value2

    # Read and execute the variable assignments from the config file. In the case of regex
    # assignments, there are some complications hidden from the user that we must unravel here.
    for line in $tableSection; do

        # Parse out the attribute and value. Skip all lines not structured this way.
        if [[ $line =~ ^[[:space:]]*([[:alnum:]_]*)[\ ]?=(.*) ]]; then
            attribute=${BASH_REMATCH[1]}
            value=${BASH_REMATCH[2]}
        else
            continue
        fi

        # Branch on the attribute. First handle the cases that pre-empt the regex state machine,
        # namely, the "default..." and the "regex" attributes
        if [[ $attribute =~ ^default([A-Z].*) ]]; then
            regexMode=$TRUE

            # Set the canonical regex and its type
            regexType=${BASH_REMATCH[1]}
            if [[ $regexType == Int ]]; then
                regex="^[-]?[:digit:]+$"
                regexType=${rgx[DEFAULT_INT]}
            elif [[ $regexType == Alpha ]]; then
                regex="^[[:alnum:]_\ .]+$"
                regexType=${rgx[DEFAULT_ALPHA]}
            elif [[ $regexType == Float ]]; then
                regex="^[-]?[:digit:]*\.[:digit:]+$"
                regexType=${rgx[DEFAULT_FLOAT]}
            elif [[ $regexType == Date ]]; then
                regex="^[0-9]{4}[/-][0-9]{1,2}[/-][0-9]{1,2}$"
                regexType=${rgx[DEFAULT_DATE]}
            fi
            g_config[regex$regexCount]=$regex
            g_config[regexType$regexCount]=$regexType
            # Increment the counter now because there might not be any further specifiers
            # for this regex. If there are, they will compensate for this pre-incrementation.
            ((regexCount++))

        elif [[ $attribute == regex ]]; then
            regexMode=$TRUE
            regex=$value
            regexType=${rgx[NORMAL]}
            g_config[regex$regexCount]=$regex
            g_config[regexType$regexCount]=$regexType
            # Do not increment the counter. The REQUIRED specifier "column" will do it.
            # ((regexCount++))

        # The state machine for regexes. Different types of regex require or accept
        # different special key-value specifiers.
        elif ((regexMode)); then

            case $regexType in
              ${rgx[DEFAULT_ALPHA]})
                # Optional specifier: length
                if [[ $attribute == length ]]; then
                    ((regexCount--))     # roll the counter back - see "Increment the counter" above
                    # Length limit(s) can be a range, a half-empty range or a solitary number
                    [[ $value =~ ^([0-9]*)([^0-9])?([0-9]*)$ ]]
                    g_config[lowerBounds$regexCount]=${BASH_REMATCH[1]}
                    if [[ -n ${BASH_REMATCH[3]} ]]; then    # 5-10 or -10
                        g_config[upperBounds$regexCount]=${BASH_REMATCH[3]}
                    elif [[ -n ${BASH_REMATCH[2]} ]]; then  # 5-
                        g_config[upperBounds$regexCount]=99999
                    else     # a solitary number
                        g_config[upperBounds$regexCount]=${BASH_REMATCH[1]}
                    fi
                    ((regexCount++))
                    regexMode=$FALSE
                else
                    # Any other specifier signals that we are no longer in regex mode.
                    # Handle the specifier generically.
                    g_config[$attribute]="$value"
                    regexMode=$FALSE
                fi
                ;;

              [${rgx[DEFAULT_INT]}${rgx[DEFAULT_FLOAT]}${rgx[DEFAULT_DATE]}])
                # Optional specifier: range
                if [[ $attribute == range ]]; then
                    ((regexCount--))     # roll the counter back - see "Increment the counter" above
                    # Store the numeric or calendar limits
                    if [[ $regexType == ${rgx[DEFAULT_INT]} ]]; then
                        [[ $value =~ ^([-]?[0-9]+)-([-]?[0-9]+)$ ]]
                    elif [[ $regexType == ${rgx[DEFAULT_FLOAT]} ]]; then
                        [[ $value =~ ^([0-9.]+)-([0-9.]+)$ ]]
                    else # [[ $regexType == ${rgx[DEFAULT_DATE]} ]]
                        # Get the date range. Only full y4/m2/d2 dates are accepted, no shortcuts.
                        [[ $value =~ ^([0-9]{4}/[0-9]{1,2}/[0-9]{1,2})-([0-9]{4}/[0-9]{1,2}/[0-9]{1,2})$ ]]
                    fi
                    g_config[lowerBounds$regexCount]=${BASH_REMATCH[1]}
                    g_config[upperBounds$regexCount]=${BASH_REMATCH[2]}
                    ((regexCount++))
                    regexMode=$FALSE
                else
                    g_config[$attribute]="$value"
                    regexMode=$FALSE
                fi
                ;;

              ${rgx[NORMAL]})
                # Required specifier: column; no other specifiers are allowed
                if [[ $attribute == column ]]; then
                    # Store the column, terminate regex mode and accept the regex
                    g_config[column$regexCount]=$value
                    # Look up the column type in the global column list and store it.
                    # In the column list, accept a populated or an unpopulated table name column
                    if [[ "$g_masterColumnList" =~ $'\n'\ [^\ ]*\ +$value[\ ]+([a-z]+) ]]; then
                        columnType=${BASH_REMATCH[1]}
                        sqlTypeToInternalType $columnType; getReturnValue columnType
                        g_config[columnType$regexCount]=$columnType
                        ((regexCount++))
                        regexMode=$FALSE
                    else
                        regexMode=$FALSE
                        setError ${rc[ILL_FORMED_CONFIG_FILE]} "Error: Unable to find column '\$value' in table '\$tableName'."
                        return $?
                    fi
                else
                    regexMode=$FALSE
                    setError ${rc[ILL_FORMED_CONFIG_FILE]}
                    return $?
                fi
                ;;
            esac

        # Normal variable assignments should be performed literally
        else
            eval g_config[\$attribute]=\"$value\"
        fi
    done

    g_config[regexCount]=$regexCount
    if [[ -z ${g_config[mainTable]} ]]; then g_config[mainTable]=$tableName; fi

    return ${rc[SUCCESS]}
}

##########################################################################################
# swapValueParameterToFront ("$@")
# Prepares a move of the first value parameter (i.e. the first non-option) to the
# first position, by constructing a string that can be eval-setted by the caller
##########################################################################################
function swapValueParameterToFront()
{
    declare -i index
    local param
    local paramList='"$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"'

    if [[ "$1" =~ ^[+-] ]]; then
        index=1
        for param in "$@"; do
            if [[ "$param" =~ ^[^+-] ]]; then
                break
            else
                ((index++))
            fi
        done
        if ((index>1 && index<=$#)); then
            # Swap the identified parameter with $1
            paramList=${paramList/$index/1}
            paramList=${paramList/1/$index}
            # Chop down to the actual number of parameters: delete "$($#+1)" and whatever follows
            paramList=${paramList%'"$'$(($#+1))*}
        else
            setError ${rc[MISSING_ARGUMENT]}
            return $?
        fi
    fi

    setReturnValue "$paramList"
    return ${rc[SUCCESS]}
}

##########################################################################################
# parseOutOptions  command_line...
# Given a set of arguments, this function constructs and returns two strings in one:
#  (1) A colon-delimited string listing the OPTIONS detected. These are the arguments that begin
#      with a "-" sign, plus the special "*" option which we encode as 'selectAll'.
#  (2) A symbolic list of the args that are not options, e.g. if $1 and $4 are not options, then
#      this string will be set to "${1} ${4}" (where all characters between quotes are literal).
#      This enables the caller to easily remove the option arguments from his command line
#      by calling the "set" builtin.
# Return code = number of option arguments detected
##########################################################################################
function parseOutOptions()
{
    local OPTION_LIST retArgs retCode
    local arg nextArg

    for ((idx=1; idx<=$#; idx++)); do
        eval arg=\$$idx      # value of the idx-th argument ($idx is just the index number)

        # Identify the "normal" option arguments; "-" plus the option name and sometimes a value
        if [[ "$arg" =~ ^[-]+[[:alnum:]] ]]; then

            # For options having settable values we accept 3 forms:  -op=Val  -opVal  or  -op Val
            arg=${arg/=/}                         # Squeeze out the = sign
            if [[ $arg =~ ^[-]+[Ll]$ ]]; then        # Squeeze out the space, i.e. add the following argument
                ((++idx))
                eval newArg=\$$idx
                if [[ ! $newArg =~ ^[0-9]+$ ]]; then
                    echo Error: Limit must be numeric. > $g_errorStream
                    exit 20
                fi
                arg+=$newArg
            fi

            # Add the option to the internal list
            OPTION_LIST+=":"${arg##+(-)}
            ((retCode++))

        # Interpret the special "*" argument as the selectAll option
        elif [[ "$arg" == "*" ]]; then
            OPTION_LIST+=":selectAll"
            ((retCode++))

        # Otherwise the argument is not an option.
        else
            retArgs+='"${'$idx'}" '
        fi
    done

    retArgs="${retArgs% }"
    OPTION_LIST+=":"

    # Make the options case-agnostic by always storing them in lowercase
    setReturnValues "${OPTION_LIST,,}" "$retArgs"

    return $retCode
}

##########################################################################################
# expandInterval (interval, intervalType)
#
# Expands two types of possibly-abbreviated value sets into their full-length equivalents:
#   (1) ranges (numeric or date) --> pairs of interval endpoints
#         e.g.  "100200300-99" --> "100200300 <delim> 100200399"
#               "2013/10-12" --> "2013-10-01 <delim> 2013-12-31"   (use / within dates, - to delimit ranges)
#               "2013/10/5-20" --> "2013-10-5 <delim> 2013-10-20"
#   (2) prefix lists --> normal lists
#         e.g.  "1002003:00,99" --> "100200300,100200399"   (use : after prefix, commas to delimit)
##########################################################################################
function expandInterval()
{
    local first=${1%[-:]*}
    local second=${1#*[-:]}
    local filler='???????????????'
    declare -r NUM_RANGE=1 DATE_RANGE=2
    local firstArg secondArg response

    if (($2 == NUM_RANGE)); then
        # greater/less than the parsed-out values
        firstArg=$first
        if [[ ${#second} -lt ${#first} ]]; then
            secondArg=${first/%${filler:0:${#second}}/$second}
        else
            secondArg=$second
        fi
        response=$firstArg
        response+=$delim
        response+=$secondArg

    elif (($2 == DATE_RANGE)); then
        # Base the parsing on the slash count before/after hyphen:
        # two before ...
        if [[ $first =~ /[[:digit:]]+/ ]]; then
            firstArg=$first
            # two after ...
            if [[ $second =~ /[[:digit:]]+/ ]]; then
                secondArg=$second
            # one after ...
            elif [[ $second =~ / ]]; then
                secondArg=${first%%/*}/$second
            # none after ...
            else
                secondArg=${first%/*}/$second
            fi
        # one before ...
        elif [[ $first =~ / ]]; then
            firstArg=$first/01
            # one after ...
            if [[ $second =~ / ]]; then
                secondArg=$second/31
            # none after but there is a number ...
            elif [[ $second =~ [0-9] ]]; then
                secondArg=${first%/*}/$second/31
            # second is blank altogether ...
            else
                secondArg=$first/31
            fi
        else
            response="Error in date range."
        fi

        # Turn /'s into -'s for SQL compatibility
        firstArg=${firstArg//\//-}
        secondArg=${secondArg//\//-}

        response=$firstArg
        response+=$delim
        response+=$secondArg

    else
        response="Not a range."
    fi

    setReturnValue "$response"
}

##########################################################################################
# parseOutSets  command_line...
#
# Given a list of arguments, this function constructs and returns a pseudo-SET clause for use
# in an UPDATE stmt, where the values are delimited with special markers;
# a comma-list of the (abbreviated) column names in the clause; and a symbolic list of the remaining (non-SET-type) arguments
#
# Note: A SET-type argument is a "name-op-value" tuple where "op" is :=
#
# Returns the number of SET particles detected
##########################################################################################
function parseOutSets()
{
    local SET_CLAUSE abbrList retArgs name value
    declare -i haveSets=0

    for ((idx=1; idx<=$#; idx++)); do
        eval arg=\$$idx      # value of the idx-th argument ($idx is just the index number)

        # If the arg is a SET-type arg...
        if [[ "$arg" =~ [[:alnum:]]${updateOperator}. ]]; then
            # Construct a proto-SET clause using markers to identify the values; "column:=value" becomes "column = @value@,"
            SET_CLAUSE+=" ${arg/${updateOperator}/ = $setClauseMarker}$setClauseMarker,"
            # Parse out the column abbr from the supplied argument
            abbrList+=${arg%${updateOperator}*},
            ((haveSets++))
        else
            retArgs+='"${'$idx'}" '
        fi
    done

    SET_CLAUSE=${SET_CLAUSE%,}
    abbrList=${abbrList%,}

    setReturnValues "${SET_CLAUSE:-$placeholderForEmpty}" "${abbrList:-$placeholderForEmpty}" "$retArgs"

    return $haveSets
}

##########################################################################################
# parseOutSelects  command_line...
#
# Given a set of arguments, this function constructs and returns two strings representing
# the pre- and post-selected columns, plus a symbolic list of the remaining (non-selection) arguments
#
# Selection-type arguments can be singletons or comma-separated lists in the following forms:
#    +0 or +00       to clear most or all of the default columns
#    +1columnName    to prepend a column
#    +columnName     to append a column
#  #FUTURE:  ++groupName     to append a column class (the caller needs to expand and append)
#
# Return codes:
#  retCode_ordinarySelection    if selections are detected and no special flags are among them
#  retCode_clearAllSelections   if "00"/clearAll is detected,
#  retCode_selectMainColumnOnly if "0"/clearMost is detected,
#  retCode_noSelection          if no selection arguments are detected
##########################################################################################
function parseOutSelects()
{
    local PRESELECTION_LIST POSTSELECTION_LIST retArgs
    declare -i retCode=$retCode_ordinarySelection

    local zeroInListRegex="(^|,)(00?)($|,)"     # a single or double zero within a comma-separated list
    local groupNameRegex="^\+"              # begins with literal "+".

    for ((idx=1; idx<=$#; idx++)); do
        eval arg=\$$idx      # value of the idx-th argument ($idx is just the index number)
        eval nextArg=\$$((idx+1))

        isArgOfType "$arg" selection
        if (($?)); then
            # Strip off plus sign
            value=${arg#+}

            # Handle "+0(0)?" / "+ 0(0)?" by setting the clear-defaults flag and erasing the fake zero "column".
            # The caller will then have to clear the default selections since this function cannot access them
            # (If 0 is embedded in a list we will handle it below, within the list)
            if [[ $value =~ ^00?$ || ( $value == "" && "$nextArg" =~ ^00?$ ) ]]; then
                if [[ -z $value ]]; then shift; fi
                : ${value:=$nextArg}
                if [[ $value = "00" ]]; then
                    retCode=$retCode_clearAllSelections
                else
                    retCode=$retCode_selectMainColumnOnly
                fi

            # Handle "+1value" / "+1 value". If the value is or contains a "0" column, remove it and set the return value.
            # In all cases, add whatever remains to the selection list
            elif [[ $value =~ ^1 ]]; then
                value=${value#1}
                if [[ -z $value ]]; then shift; fi
                : ${value:=$nextArg}
                if [[ $value =~ $zeroInListRegex ]]; then
                    retCode=$retCode_selectMainColumnOnly
                    if [[ (${BASH_REMATCH[1]} == ,) && (${BASH_REMATCH[3]} == ,) ]]; then
                        value=${value/${BASH_REMATCH[0]}/,}
                    else
                        value=${value/${BASH_REMATCH[0]}/}
                    fi
                fi
                PRESELECTION_LIST+=$value","

            # Handle "++1value" / "++value"
            elif [[ $value =~ $groupNameRegex ]]; then
                # Leave the remaining plus sign there to tell caller this is a group name
                if [[ ${value:1:0} == 1 ]]; then
                    if [[ -n ${value:2:0} ]]; then
                        PRESELECTION_LIST+=${value/1/},     # Leave + but remove 1
                    else
                        PRESELECTION_LIST+="+"$nextArg","
                        shift
                    fi
                else
                    if [[ -n ${value:1:0} ]]; then
                        POSTSELECTION_LIST+=","$value
                    else
                        POSTSELECTION_LIST+=",+"$nextArg
                        shift
                    fi
                fi

            # Handle "+value" / "+ value". This can include value lists which, if they contain a "0", must be handled
            # by removing the 0 and setting the return value.
            else
                if [[ -z $value ]]; then shift; fi
                : ${value:=$nextArg}
                if [[ $value =~ $zeroInListRegex ]]; then
                    retCode=${#BASH_REMATCH[2]}
                    if [[ (${BASH_REMATCH[1]} == ,) && (${BASH_REMATCH[3]} == ,) ]]; then
                        value=${value/${BASH_REMATCH[0]}/,}
                    else
                        value=${value/${BASH_REMATCH[0]}/}
                    fi
                fi
                POSTSELECTION_LIST+=","$value
            fi

        # The arg is not a selection. Add it to the return list.
        else
            retArgs+='"${'$idx'}" '
        fi

    done

    PRESELECTION_LIST=${PRESELECTION_LIST%,}
    POSTSELECTION_LIST=${POSTSELECTION_LIST#,}

    setReturnValues "${PRESELECTION_LIST:-$placeholderForEmpty}" "${POSTSELECTION_LIST:-$placeholderForEmpty}" "$retArgs"

    return $retCode
}

##########################################################################################
# generateWhereClause  [givenWhereParticles ...]
#
# Builds the core WHERE-clause from the supplied predicates. These can be in basic or compound form.
#
# We call the basic-form predicates "NCV (name-comparator-value)" expressions. If the name is
# omitted it will be inferred based on the global settings g_default{Num,Alnum}Cols. If the comparator
# is also omitted it will default to "=". Examples of NCV expressions include:
#
#    n,c,v all present:            column=y   column!=y
#    n omitted:                    <=y   =x,y,z
#    n,c omitted:                  x   x,y,z   x-y
#
# and compound-form arguments are boolean combinations of these.
##########################################################################################
function generateWhereClause()
{
    # Declare return data
    local WHERE_CLAUSE=""
    local valuesToSortBy columnToSortBy

    # Declare helper variables
    declare -i numWheres=0 numDftNumCols=0 numDftAlnumCols=0 totalArguments=$#
    declare -a whereComponent
    local name code comparator value
    local valueType rhs

    # Array-ify the column name inference rules
    declare -a defaultNumCols defaultAlnumCols dftNumCodes dftAlnumCodes columnNames columnCodes
    OLDFS="$IFS"; IFS=$','
    defaultNumCols=($g_defaultNums)
    dftNumCodes=($g_defaultNumCodes)
    defaultAlnumCols=($g_defaultAlnums)
    dftAlnumCodes=($g_defaultAlnumCodes)
    IFS="$OLDFS"

    # This function receives a sequence of WHERE-clause-like arguments and produces the
    # corresponding WHERE-clause SQL. Each argument takes the form of a boolean combination of
    # NCV expressions. Our plan of attack is to separate them into individual NCVs, call some
    # processing functions on each one, and then link them back together with the right booleans.

    # Set the highest-level conjunction, defaulting to AND.
    isOptionOn 'o|or' $OPTIONS
    if (($?)); then
        g_mainConjunction=OR
    else
        isOptionOn 'a|and' $OPTIONS
        if (($?)); then
            g_mainConjunction=AND
        fi
    fi

    # Handle each argument in turn
    while [[ -n $1 ]]; do

        # Parse and lexically analyze the argument
        parseQueryClause "$1" $TRUE
        getReturnValue rhs

        # Begin the SQL subclause for the current argument
        local sql="$g_mainConjunction "
        # If this subclause is one of several, enclose it in '(...)'
        # to ensure the "main" conjunction has least precedence
        if ((totalArguments > 1)); then
            sql+="( "
        fi

        # Break up the argument into its n-c-v predicates. For each predicate, invoke the low-level SQL
        # generators and link the predicates together with the right boolean conjunctions
        while [[ -n $rhs ]]; do
            local predicate predicateType ncvCounter totalTokenCount newSql
            local givenComparator effectiveComparator comparatorPosition nestingLevel

            # Pull the next predicate, boolean, or parenthesis token from the parsed string

            # Identify front-delimiters for predicates
            if [[ $rhs =~ ^${tokenDelimiter}${tt[BEGIN_NCV]}([0-9]+) ]]; then
                ncvCounter=${BASH_REMATCH[1]}
                advanceStream "$rhs" ${BASH_REMATCH[0]}; getReturnValue rhs

                # Retrieve the end delimiter
                [[ $rhs =~ $tokenDelimiter([$g_ncvTypeMarkers])([0-9]+)(.*) ]]
                predicate=${rhs%${BASH_REMATCH[0]}}
                predicateType=${BASH_REMATCH[1]}
                totalTokenCount=${BASH_REMATCH[2]}
                rhs=${BASH_REMATCH[3]}

                # "Clean up" the predicate. Open with "(" or "NOT (" as appropriate.
                # Perform expansions and transformations.
                normalizePredicate $predicateType "$predicate" || return $?
                getReturnValues predicate effectiveComparator comparatorPosition

                # Build the SQL fragment for the current predicate. Choose a builder based on
                # whether the predicate contains an explicit name.
                if [[ $predicateType == ${tt[TYPE_NCV]} ]]; then
                    processNamedNCVArgument "$predicate" $effectiveComparator $comparatorPosition
                else
                    processUnnamedNCVArgument "$predicate" $effectiveComparator $comparatorPosition
                fi

                getReturnValues newSql givenComparator
                sql+=$newSql

                # If the comparator was changed by normalizePredicate(), then a "(" needs to be closed
                if [[ "$effectiveComparator" != "$givenComparator" ]]; then
                    sql+=") "   # Close the "NOT ( " that was factored out
                fi
                continue

            # Left grouping parentheses. Regex note: Since we are at predicate level, there will be no token counter.
            elif [[ $rhs =~ ^$tokenDelimiter${tt[BEGIN_GROUP]}([0-9]+) ]]; then
                sql+="("
                nestingLevel=${BASH_REMATCH[1]}
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue

            # Right grouping parentheses
            elif [[ $rhs =~ ^$tokenDelimiter${tt[END_GROUP]}([0-9]+) ]]; then
                sql+=")"
                nestingLevel=${BASH_REMATCH[1]}
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue

            # Logical operators
            elif [[ $rhs =~ ^${tokenDelimiter}${tt[BOOLEAN]}'&' ]]; then
                sql+=" AND"
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue
            elif [[ $rhs =~ ^${tokenDelimiter}${tt[BOOLEAN]}'|' ]]; then
                sql+=" OR"
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue

            # space markers
            elif [[ $rhs =~ ^$tokenDelimiter${tt[SPACE]} ]]; then
                sql+=" "
                advanceStream "$rhs" 2; getReturnValue rhs
                continue
            fi

        done

        # Finalize the subclause for this argument
        if ((totalArguments > 1)); then
            sql+=") "
        fi
        whereComponent[numWheres++]=$sql

        # Get ready to process the next argument
        shift
    done

    # Assemble the WHERE clause from its components
    if ((numWheres > 0)); then
        WHERE_CLAUSE="${whereComponent[@]}"
    fi

    # Pass back all necessary information to the caller
    setReturnValues "$WHERE_CLAUSE" "$columnToSortBy" "$valuesToSortBy"

    return ${rc[SUCCESS]}
}


########################################################################################################
# getEffectiveComparator (predicate)
# returns comparator, comparatorPosition
#
# Obtains the comparator for a predicate, and if negative, factors out a negator and inverts the comparator
########################################################################################################
function getEffectiveComparator()
{
    local predicate=$1
    local comparator comparatorPosition

    if [[ $predicate =~ ${tokenDelimiter}([0-9]+)${tt[COMPARATOR]}[0-9]+([=\<\!\>]+) ]]; then
        comparatorPosition=${BASH_REMATCH[1]}
        comparator=${BASH_REMATCH[2]}
    else
        comparatorPosition=0
        comparator='='
    fi

    # If the comparator is negative ('<>' or '!=') then factor out a NOT and invert the comparator
    isNegativeComparator "$comparator"
    if (($?)); then
        sql+="NOT ( "  # The '(' is needed when complex internal operands unravel into chains of ORs
        comparator='='
    fi

    setReturnValues "$comparator" "$comparatorPosition"
}

########################################################################################################
# normalizePredicate (predicateType, predicate)
# Processes the marked up token stream for a single name-comparator-value predicate
# into a format where the corresponding SQL can be generated with a fairly simple left-to-right scan
# Note: The call to getEffectiveComparator() generates the SQL prefix of "NOT (" if appropriate.
########################################################################################################
function normalizePredicate()
{
    local predicateType=$1
    local predicate=$2
    local effectiveComparator
    declare -i comparatorPosition
    local transformations

    # "Expand" and "transform" the predicate to its final state from which SQL can be constructed
    # readily with a single left-to-right pass over the data stream
    smartExpandExpression "$predicate" && getReturnValues predicate transformations || return $?
    applyTransformations "$predicate" "$transformations"; getReturnValue predicate

    # To further simplify constructing the SQL, we will recast negative comparators as positive
    # ones by factoring out the implied NOTs. This also makes working with NULLs easier.
    getEffectiveComparator "$predicate"; getReturnValues effectiveComparator comparatorPosition

    setReturnValues "$predicate" "$effectiveComparator" "$comparatorPosition"
}

########################################################################################################
# denudeTokens (sequence)
# Strips markup from a token sequence to reveal the user's original input.
# This version is valid for streams that have been marked up but not yet expanded, transformed or unraveled
########################################################################################################
function denudeTokens()
{
    local stream=$1 output="" td=$tokenDelimiter
    local currentToken tokenType tokenValue

    while [[ -n "$stream" ]]; do
        [[ "$stream" =~ ^$td[0-9]*(.)([^$td]*)(${td}.*)?$ ]]
        tokenType=${BASH_REMATCH[1]}
        currentToken=${BASH_REMATCH[2]}
        stream=${BASH_REMATCH[3]}

        case $tokenType in
            ${tt[SPACE]})
                output+=" "
                ;;
            ${tt[DELIMITER]})
                output+=","
                ;;
            [${tt[OPERATOR]}${tt[COMPARATOR]}])
                # Skip the level number
                [[ "$currentToken" =~ [0-9]+(.*) ]]
                output+=${BASH_REMATCH[1]}
                ;;
            [$g_expandableTypes])
                # Before expansion, token contains the name only
                output+=$currentToken
                ;;
            [${tt[BEGIN_FUNCTION]}${tt[BEGIN_GROUP]}])
                output+="("
                ;;
            [${tt[END_FUNCTION]}${tt[END_GROUP]}])
                output+=")"
                ;;
            ${tt[FILENAME]})
                output+="@"$currentToken"@"
                ;;
            [$g_expandedTypes])
                # After expansion, token begins with the internal type
                output+=${currentToken:1}
                ;;
            ${tt[BOOLEAN]})
                # "&" and "|" mean "&&" and "||", respectively
                output+=$currentToken$currentToken
                ;;
            [${tt[BEGIN_NCV]}$g_ncvTypeMarkers])
                ;;
            *)
                output+=$currentToken
                ;;
        esac
    done

    setReturnValue "$output"
}

########################################################################################################
# processNamedNCVArgument (predicate, effectiveComp, compPosition)
# A major subroutine of generateWhereClause() that builds a SQL snippet for a name-comparator-value construct
# whose "name" component is explicitly provided
########################################################################################################
function processNamedNCVArgument()
{
    local predicate=$1 effectiveComparator=$2 comparatorPosition=$3
    local currentToken tokenType tokenValue givenComparator
    local currentSide=$LEFT_SIDE currentName
    local firstValue secondValue
    local filler'=???????????????' td=$tokenDelimiter sql=""

    # Loop over the tokens, generating the right SQL for each. Special token types need to be "unraveled"
    # beforehand, so we process all tokens case-by-case depending on their type.
    local tempPredicate=$predicate
    while [[ -n "$tempPredicate" ]]; do

        # Pick out the next token
        [[ "$tempPredicate" =~ ^$td[0-9]*(.)([^$td]*)(${td}.*)?$ ]]
        tokenType=${BASH_REMATCH[1]}
        currentToken=${BASH_REMATCH[2]}
        tempPredicate=${BASH_REMATCH[3]}

        # Extract the token value(s) and type. Special tokens must first be unraveled to their underlying data.
        case $tokenType in
            ${tt[SPACE]})
                tokenValue=" "
                ;;
            ${tt[OPERATOR]})
                [[ "$currentToken" =~ [0-9]+(.*) ]]
                tokenValue=${BASH_REMATCH[1]}
                ;;
            ${tt[COMPARATOR]})
                # Use the positive comparator, which might not be the original
                [[ "$currentToken" =~ [0-9]+(.*) ]]
                givenComparator=${BASH_REMATCH[1]}
                tokenValue=$effectiveComparator
                ;;
            [$g_expandedTypes])
                # Skip the data type of the expanded name
                [[ "$currentToken" =~ (.)(.*) ]]
                tokenValue=${BASH_REMATCH[2]}
                ;;
            ${tt[END_FUNCTION]})
                # Trim some extra material from the input expression
                [[ "$tempPredicate" =~ ^${tt[FUNCTION_ARITY]}[0-9]+(.*) ]]
                tempPredicate=${BASH_REMATCH[1]}
                ;;
            ${tt[FILENAME]})
                # Unwind the filename token to the underlying list and change the type to the underlying type
                convertFileTokenToList "$currentToken" "$currentName"
                getReturnValues tokenValue tokenType
                ;;
            ${tt[DATE_RANGE]})
                # Convert into a pair of interval endpoints
                expandDateRange "$currentToken"; getReturnValues firstValue secondValue
                ;;
            ${tt[INT_RANGE]})
                # Convert into a pair of interval endpoints
                [[ $currentToken =~ (.*)-(.*) ]]
                firstValue=${BASH_REMATCH[1]}
                secondValue=${BASH_REMATCH[2]}
                # In case of an abbreviated second value, paste its digits over the end of the first
                if [[ ${#secondValue} -lt ${#firstValue} ]]; then
                    secondValue=${firstValue/%${filler:0:${#secondValue}}/$secondValue}
                fi
                ;;
            ${tt[PREFIX_LIST]})
                # Convert to an integer list
                [[ $currentToken =~ (.*):(.*) ]]
                tokenValue=":"${BASH_REMATCH[2]}
                tokenValue=${tokenValue//[:,]/,${BASH_REMATCH[1]}}
                tokenValue=${tokenValue#,}
                tokenType=${tt[INT_LIST]}
                ;;
            *)
                tokenValue=$currentToken
                ;;
        esac

        # Generate the correct SQL for the token data and type
        case $tokenType in
            ${tt[NATIVE_TYPE]})
                if [[ $tokenValue == $NULL_INDICATOR ]]; then
                    # Isolated (non-list) nulls
                    sql+="IS NULL "
                else
                    sql+="= $PREPARED_STMT_PARM "
                    setOption "query"    # disable auto-execute in the case of prepared statements
                fi
                pendingEqualsSign=$FALSE
                ;;
            ${tt[SPACE]})
                sql+=$tokenValue
                ;;
            ${tt[OPERATOR]})
                sql+="$tokenValue "
                ;;
            ${tt[COMPARATOR]})
                if [[ $tokenValue == '=' ]]; then
                    # Proper interpretation of the equals sign depends on the succeeding token
                    pendingEqualsSign=$TRUE
                else
                    sql+="$tokenValue "
                fi
                currentSide=$RIGHT_SIDE
                ;;
            [$g_expandedTypes])
                if [[ $pendingEqualsSign == $TRUE ]]; then
                    sql+="= "
                    pendingEqualsSign=$FALSE
                fi
                currentName=$tokenValue
                sql+="$tokenValue "
                ;;
            ${tt[BEGIN_FUNCTION]})
                sql+="("
                ;;
            ${tt[BEGIN_GROUP]})
                if [[ $pendingEqualsSign == $TRUE ]]; then
                    sql+="= "
                    pendingEqualsSign=$FALSE
                fi
                sql+="("
                ;;
            [${tt[END_FUNCTION]}${tt[END_GROUP]}])
                sql+=")"
                ;;
            ${tt[DELIMITER]})
                sql+=", "
                ;;
            [${tt[STRING_CONSTANT]}${tt[DATE]}${tt[TIME]}])
                if [[ $pendingEqualsSign == $TRUE ]]; then
                    sql+="= "
                    pendingEqualsSign=$FALSE
                fi
                sql+="'$tokenValue' "
                ;;
            ${tt[ALNUM_REGEX]})
                sql+="LIKE '$tokenValue' "
                pendingEqualsSign=$FALSE
                ;;
            ${tt[REGEX_LIST]})
                regexListToSQL "$tokenValue" "$currentName"; appendReturnValue sql
                pendingEqualsSign=$FALSE
                ;;
            [${tt[DECIMAL]}${tt[INTEGER]}])
                if [[ $pendingEqualsSign == $TRUE ]]; then
                    sql+="= "
                    pendingEqualsSign=$FALSE
                fi
                sql+="$tokenValue "
                ;;
            ${tt[ALNUM_LIST]}${tt[DATE_LIST]})
                valueListToSQL "$tokenValue" "$currentName" $TRUE; appendReturnValue sql
                pendingEqualsSign=$FALSE
                ;;
            [${tt[FLOAT_LIST]}${tt[INT_LIST]}])
                valueListToSQL "$tokenValue" "$currentName" $FALSE; appendReturnValue sql
                pendingEqualsSign=$FALSE
                ;;
            ${tt[DATE_RANGE]})
                sql+="BETWEEN '$firstValue' AND '$secondValue' "
                pendingEqualsSign=$FALSE
                ;;
            ${tt[INT_RANGE]})
                sql+="BETWEEN $firstValue AND $secondValue "
                pendingEqualsSign=$FALSE
                ;;
            ${tt[FORCED_EXPANSION]})
                ;;
            *)
                echo "Unsupported token type: '$tokenType'"
                return 1
                ;;
        esac
    done

    setReturnValues "$sql" "$givenComparator"
}

#####################################################################################################
# convertFileTokenToList (fileName, columnName)
#
# Unravels a FILENAME-type token to a list-type token and determines the type of list
#####################################################################################################
function convertFileTokenToList()
{
    local fileName=$1 columnName=$2 msg
    local tokenValue tokenType

    # If the data is stdin-sourced (i.e. no filename was given), prompt the user for it
    if [[ -z $fileName ]]; then
        if [[ -n $columnName ]]; then msg="for '$columnName' "; else msg=; fi
        echo '>>> Your values '$msg '(finish with <enter> <ctrl-D>):' > $g_errorStream
    fi

    # Load and strip the values. Some extra cleanup is needed that doesn't apply to cmdline lists.
    loadFileAsCommaList "${fileName:-/dev/stdin}"; getReturnValue tokenValue

    # Discern the underlying data type. (It will be one of the list types, of course.)
    # Check for numeric types: digits, negative sign / dash, decimal point
    if [[ $tokenValue =~ ^[-0-9,.]+$ ]]; then
        # Dates have "-"s in their interior, numbers do not
        if [[ $tokenValue =~ [^,]- ]]; then
            tokenType=${tt[DATE_LIST]}
        else
            if [[ $tokenValue =~ [.] ]]; then
                tokenType=${tt[FLOAT_LIST]}
            else
                tokenType=${tt[INT_LIST]}
            fi
        fi
    # An alphabetic type
    else
        if [[ $tokenValue =~ [%_] ]]; then
            tokenType=${tt[REGEX_LIST]}
        else
            tokenType=${tt[ALNUM_LIST]}
        fi
    fi

    setReturnValues "$tokenValue" "$tokenType"
}

#####################################################################################################
# expandDateRange (token)
#
# Breaks down a possibly-abbreviated date range into a pair of yyyy-dd-mm dates
#####################################################################################################
function expandDateRange()
{
    local token=$1 firstValue secondValue

    [[ $token =~ (.*)-(.*) ]]
    firstValue=${BASH_REMATCH[1]}
    secondValue=${BASH_REMATCH[2]}

    # Base the parsing on the slash count before/after hyphen:
    # two before ...
    if [[ $firstValue =~ /[[:digit:]]+/ ]]; then
        # First value is complete as-is. As for the second:
        # two after ...
        if [[ $secondValue =~ /[[:digit:]]+/ ]]; then
            secondValue=$secondValue
        # one after ...
        elif [[ $secondValue =~ / ]]; then
            secondValue=${firstValue%%/*}/$secondValue
        # none after ...
        else
            secondValue=${firstValue%/*}/$secondValue
        fi
    # one before ...
    elif [[ $firstValue =~ / ]]; then
        firstValue=$firstValue/01
        # one after ...
        if [[ $secondValue =~ / ]]; then
            secondValue=$secondValue/31
        # none after but there is a number ...
        elif [[ $secondValue =~ [0-9] ]]; then
            secondValue=${firstValue%%/*}/$secondValue/31
        # secondValue is blank altogether ...
        else
            secondValue=$firstValue/31
        fi
    else
        echo "Error in date range." > $g_errorStream
    fi

    # Turn /'s into -'s for SQL compatibility
    firstValue=${firstValue//\//-}
    secondValue=${secondValue//\//-}

    setReturnValues $firstValue $secondValue
}

#####################################################################################################
# regexListToSQL (list, columnName)
#
# Generates SQL for REGEX_LISTs
#####################################################################################################
function regexListToSQL()
{
    declare -a valueArray
    local value output=""
    local currentName=$2
    declare -i hasNull=$FALSE bufferedName=$TRUE

    OLDIFS=$IFS; IFS="," valueArray=($1)

    # Render each value in the list in regex form or in fixed-string form, as appropriate
    for value in ${valueArray[@]}; do

        # Regex values
        if [[ $value =~ [%_] ]]; then
            # Be careful not to duplicate the name at the outset
            if [[ $bufferedName == $TRUE ]]; then
                output+="LIKE '$value' OR "
                bufferedName=$FALSE
            else
                output+=$currentName" LIKE '$value' OR "
            fi

        # NULLs
        elif [[ $value == $NULL_INDICATOR ]]; then
            hasNull=$TRUE

        # Fixed-string values
        else
            # Be careful not to duplicate the name at the outset
            if [[ $bufferedName == $TRUE ]]; then
                output+=" = '$value' OR "
                bufferedName=$FALSE
            else
                output+=$currentName" = '$value' OR "
            fi
        fi
    done
    IFS=$OLDIFS

    if [[ $hasNull == $TRUE ]]; then
        output+=$currentName" IS NULL "
    fi
    output=${output% OR }

    setReturnValue "$output"
}

#####################################################################################################
# valueListToSQL (list, columnName, doQuoteList)
#
# Generates SQL for lists of (flat) values
#####################################################################################################
function valueListToSQL()
{
    local values=$1 currentName=$2
    local br2 output
    declare -i hasNull=$FALSE doQuoteList=$3

    # Turn embedded NULLs into a separate indicator
    if [[ $values =~ (^|,)$NULL_INDICATOR(,|$) ]]; then
        hasNull=$TRUE
        br2=${BASH_REMATCH[2]}
        # Keep one comma, delete the other
        if [[ "${BASH_REMATCH[1]}" == , ]]; then br2=; fi
        values="${values/${BASH_REMATCH[1]}$NULL_INDICATOR$br2/}"
    fi

    # To post-sort the result set, we record the values and the column name, always using the FIRST value list we encounter.
    if [[ -z $columnToSortBy ]]; then
        valuesToSortBy=$values
        columnToSortBy=$currentName
    fi

    # Quote the list
    if [[ $doQuoteList == $TRUE ]]; then
        values="'"${values//,/\',\'}"'"
    fi

    # Construct the final piece of SQL
    if [[ $hasNull == $TRUE ]]; then
        output+="IN ($values) OR $currentName IS NULL "
    else
        output+="IN ($values) "
    fi

    setReturnValue "$output"
}


########################################################################################################
# processUnnamedNCVArgument
# A major subroutine of generateWhereClause() that builds a SQL snippet for a name-comparator-value construct
# that lacks an explicit "name" component
########################################################################################################
function processUnnamedNCVArgument()
{
    local singleCol predicate=$1 effectiveComparator=$2 comparatorPosition=$3

    # Turn regex values (singletons or lists) into "LIKE" particles
    isArgOfType "$value" alnumRegex
    if (($?)); then

        # Desired output: "{AND,OR} [NOT] (x LIKE 'y' OR x LIKE 'z' OR ...)"
        OLDIFS="$IFS"; IFS=","; valueArray=("$value")
        for singleCol in ${defaultAlnumCols[@]}; do
            local single_col=${singleCol%%:*}
            for singleVal in ${valueArray[@]}; do
                if [[ "$single_col" =~ [%_] ]]; then
                    sql+=$single_col" LIKE '${singleVal}' OR "
                else
                    sql+=$single_col" = '${singleVal}' OR "
                fi
            done
            if ((_wheres_bIncludesNull)); then
                sql+=$single_col" IS NULL OR "
            fi
        done
        IFS="$OLDIFS"

    elif ((_wheres_bIsRange)); then
        # TODO Ranges can be numeric or date ranges, but we only do integer- and alpha-type column inference,
        # so that is all that will work here. Maybe some day we will add default float- and date-type columns.
        for singleCol in ${defaultNumCols[@]}; do
            code=${dftNumCodes[numDftNumCols]}

            quoteRangeValueIfNeeded "$value" $code; getReturnValue value

            local lowValue=${value%$delim*}
            local highValue=${value#*$delim}

            sql+="$singleCol BETWEEN $lowValue AND $highValue OR "
        done

    # Strict alpha or numeric values, no regexes
    else

    # Process numeric values -- singletons and lists
    isArgOfType "$value" "integer|intList|float|floatList|null"
    valueType=$?

    if ((valueType>0)); then

        # Format decimal values and lists of decimal values
        if ((valueType==3)); then
            formatValueIfDecimal "$value"; getReturnValue value
        elif ((valueType==4)); then
            formatValueIfDecimalList "$value"; getReturnValue value
        fi

        # Construct a query fragment piece-by-piece by iterating over the default columns
        for singleCol in ${defaultNumCols[@]}; do
            code=${dftNumCodes[numDftNumCols]}

            # If this column name has length bounds on its values, parse them out
            getValueLengthBounds "$singleCol"
            haveLengthBounds=$?
            getReturnValues singleCol minLength maxLength

            quoteListIfNeeded "$value" $code; getReturnValue fixedValue

            # Add an "OR" atom to this query fragment -- one way for lists, another way for singletons
            if ((_wheres_bIsList)); then

                # Check the values against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkListItemLengths $value $minLength $maxLength; then
                    continue
                fi

                sql+=$singleCol" IN ($fixedValue) OR "
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "
                fi

                # To re-sort the result set, we record the values (without quotes) and the column name, always using the FIRST value list we encounter.
                if [[ -z $columnToSortBy ]]; then
                    valuesToSortBy=${fixedValue//\'/}
                    columnToSortBy=${defaultNumCols[@]//:+([^\ ])/} # space-delimited list of column names
                fi

            else
                # Check the value against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkSingleItemLength $value $minLength $maxLength; then
                    continue
                fi

                # Special case of the NULL as singleton:
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "

                # General case for singletons:
                else
                    sql+=$singleCol" $comparator $fixedValue OR "
                fi
            fi

            ((numDftNumCols++))
        done

    # Process alpha-numeric values -- singletons and lists
    else
    isArgOfType "$value" "alnum|alnumList"
    valueType=$?

    if ((valueType>0)); then

        # Construct a query fragment piece-by-piece by iterating over the default columns
        for singleCol in ${defaultAlnumCols[@]}; do
            code=${dftAlnumCodes[numDftAlnumCols]}

            # If this column name has length bounds on its values, parse them out
            getValueLengthBounds "$singleCol"
            haveLengthBounds=$?
            getReturnValues singleCol minLength maxLength

            # Add an "OR" atom to the current query piece -- one way for lists, another way for singletons
            if ((_wheres_bIsList)); then

                # Check the values against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkListItemLengths $value $minLength $maxLength; then
                    continue
                fi

                # To re-sort the result set, we record the values (without quotes) and the column name, always using the FIRST value list we encounter.
                if [[ -z $columnToSortBy ]]; then
                    valuesToSortBy=$value
                    columnToSortBy=${defaultAlnumCols[@]//:+([^\ ])/} # space-delimited list of column names
                fi

                quoteListIfNeeded "$value" $code; getReturnValue fixedValue

                sql+=$singleCol" IN ($fixedValue) OR "
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "
                fi

            else   # This value is NOT a list.

                # Check the value against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkSingleItemLength $value $minLength $maxLength; then
                    continue
                fi

                # Special case of the NULL as singleton:
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "

                # General case for singletons:
                else
                    quoteSingleValueIfNeeded "$value" $code; getReturnValue fixedValue

                    sql+=$singleCol" $comparator $fixedValue OR "
                fi
            fi

            ((numDftAlnumCols++))
        done

    # Unrecognized value types
    else
        return 2
    fi
    fi
    fi

    sql=${sql% OR }
}

########################################################################################################
# HELPER FUNCTIONS for generateWhereClause and its major subroutines
########################################################################################################

function quoteSingleValueIfNeeded()
{
    local val=$1 code=$2
    if [[ $code =~ ^q ]]; then
        val="'$val'"
    fi
    setReturnValue "$val"
}

function quoteListIfNeeded()
{
    local val=$1 code=$2
    if [[ $code =~ ^q ]]; then
        val="'"${val//,/\',\'}"'"
    fi
    setReturnValue "$val"
}

function quoteRangeValueIfNeeded()
{
    local val=$1 code=$2
    if [[ $code =~ ^q ]]; then
        val="'${val/$delim/'$delim'}'"
    fi
    setReturnValue "$val"
}

# Returns 1 if argument is negative, 0 otherwise
function isNegativeComparator()
{
    [[ $1 == '<>' || $1 == '!=' ]]
    return $((! ($?) ))
}


# Returns 0 if all the list items' lengths are within the bounds, 1 if there is a violation
# Arguments: (1) listBeingChecked  (2) lowerBound  (3) upperBound
function checkListItemLengths()
{
    [[ ($1 =~ (^|,)[^,]{$MIN_VALUE_LEN,$2}(,|$) ) || ($1 =~ [^,]{$(($3+1))} ) ]]
    return $((! $?))
}

# Similar to the above
function checkSingleItemLength()
{
    [[ (${#1} -lt $2) || (${#1} -gt $3) ]]
    return $((! $?))
}

function getValueLengthBounds()
{
    columnName=$1

    # Get the length bounds if they are present
    if [[ $columnName =~ : ]]; then
        haveLengthBounds=1
        [[ $columnName =~ (.*):(.*)-(.*) ]]
        columnName=${BASH_REMATCH[1]}
        minLength=${BASH_REMATCH[2]:-$MIN_VALUE_LEN}
        maxLength=${BASH_REMATCH[3]:-$MAX_VALUE_LEN}
    else
        haveLengthBounds=0
    fi

    setReturnValues "$columnName" "$minLength" "$maxLength"

    return $haveLengthBounds
}

function formatValueIfDecimal()
{
    local val=$1
    isArgOfType "$val" float
    if (($?)); then
        val=${val/#./0.}
    fi

    setReturnValue "$val"
}

function formatValueIfDecimalList()
{
    local val=$1
    isArgOfType "$val" floatList
    if (($?)); then
        val=${val/#./0.}
        val=${val//,./,0.}
    fi

    setReturnValue "$val"
}

############################################################################
# loadFileAsCommaList
# Helper function to read a list of values from a file (or stdin) into a comma-separated list.
# Features some input tolerance smarts: Blank lines are skipped, as are quotes and unprotected spaces.
############################################################################
function loadFileAsCommaList()
{
    fileName=$1
    if [[ ! -e "$fileName" ]]; then
        echo Error: $fileName: File not found.
        exit 7
    fi

    # Load the values
    mapfile -t < "$fileName"
    OLDFS=$IFS; IFS=,

    # Prep/clean the values. At each step, check the value list against a regex first so we can skip the unnecessary steps.

    # (1) single-line and commify the values
    values="${MAPFILE[*]}"
    # (2a) strip unprotected end-spaces
    if [[ "$values" =~ \ , ]]; then values=${values//+( ),/,}; fi
    if [[ "$values" =~ \ $ ]]; then values=${values%%+( )}; fi
    # (2b) strip unprotected begin-spaces
    if [[ "$values" =~ ,\  ]]; then values=${values//,+( )/,}; fi
    if [[ "$values" =~ ^\  ]]; then values=${values##+( )}; fi
    # (3) remove blank entries, which show up as consecutive or extremal commas
    if [[ "$values" =~ ,, ]]; then values=${values//,+(,)/,}; fi
    if [[ "$values" =~ ^, ]]; then values=${values##+(,)}; fi
    if [[ "$values" =~ ,$ ]]; then values=${values%%+(,)}; fi
    # (4) remove quote-protection
    if [[ "$values" =~ [$eitherQuote] ]]; then
        if [[ "$values" =~ [$eitherQuote], ]]; then values=${values//[$eitherQuote],/,}; fi
        if [[ "$values" =~ ,[$eitherQuote] ]]; then values=${values//,[$eitherQuote]/,}; fi
        if [[ "$values" =~ [$eitherQuote]$ ]]; then values=${values%%[$eitherQuote]}; fi
        if [[ "$values" =~ ^[$eitherQuote] ]]; then values=${values##[$eitherQuote]}; fi
    fi
    # Done.
    IFS=$OLDFS

    setReturnValue "$values"
}

############################################################################
# formatResultSet ( rawResultSet  [ sortInstructions  [allowFolding] ] )
#   - rawResultSet has the tabular format provided by mysql's "-t" option:
#     header first then data, surrounded in boxes
#   - sortInstructions has the form columnsToSortBy:valuesToSortBy
#     and if either side is blank, both bracketed args above are ignored
#   - allowFolding defaults to $TRUE
#
# Word-wrap a result set (if necessary) to print nicely on the screen
# and display the primary column at the front of each wrapped section.
# Although we strip the header and box from the final output, they provide
# useful information to mitigate against the difficulties of working with
# result sets in the shell.
############################################################################
function formatResultSet()
{
    local sortInstructions=$2 finalResult=""
    declare -i allowFolding=${3:-$TRUE}

    if [[ -z "$1" ]]; then
        setError ${rc[EMPTY_RESULT_SET]}; return $?
    fi

    # Be sensitive to the DOS/Unix line-endings discrepancy
    local newLine=$'\n'
    if [[ $1 =~ $'\r'$'\n' ]]; then newLine=$'\r'$'\n'; fi

    # Measure the width of the result set using the ascii-art box that mysql provides.
    # Then parse out the header and body and discard the box
    isOptionOn noHeader $OPTIONS
    if (($?)); then
        [[ $1 =~ (^[+-]+)${newLine}(.*)${newLine}\+ ]]
        resultWidth=${#BASH_REMATCH[1]}
        resultSet=${BASH_REMATCH[2]}
    else
        local plus="\+"
        # Measure the width using the top line of the ascii-art box
        # Use a regex that accepts isolated plus signs in the header
        [[ $1 =~ ^(${plus}[-+]+${plus})${newLine}($'|'.*$'|'${newLine})${plus}[+-]+${newLine}(.*)${newLine}\+ ]]
        resultWidth=${#BASH_REMATCH[1]}
        resultSet=${BASH_REMATCH[2]}${BASH_REMATCH[3]}   # [2] = column hdr   [3] = data rows
    fi

    # Corner case: embedded newlines in result data
    if [[ "$resultSet" =~ [^|+]${newLine} ]]; then   # look for a newline not preceded by the usual characters
        # TODO: pretty-print the section(s) with extra newlines
        finalResult="${resultSet//|/}"
        setReturnValue "$finalResult"
        return ${rc[SUCCESS]}
    fi

    # Before folding, pre-sort the result set if a sort is needed
    # TODO Work in progress...
    if [[ "$sortInstructions" =~ ^[a-z] ]]; then
        :
    fi

#    local foldedWidth=$((COLUMNS-KEY_WIDTH))
#    if ((foldedWidth < 1)); then
    if ((resultWidth < COLUMNS || allowFolding == FALSE)); then
        # Do not fold; the result is narrow enough for the screen or the caller has turned folding off
        # TODO If we've monkeyed with the column ordering of the result set for the reasons below, we need to clean up the monkeying before setting FOLDED_RESULT here.
        finalResult="${resultSet//|/}"
        setReturnValue "$finalResult"
        return ${rc[SUCCESS]}
    else

        # Determine the width of the "key" column.
        # TODO This function currently assumes the key column is the first column. Change this function and its caller(s)
        # TODO so that this becomes a universally valid assumption, i.e. reorder the select clause before running the query!
        [[ "$resultSet" =~ ^(\|[^|]*)\ \| ]]
        local KEY_HDR=${BASH_REMATCH[1]}
        KEY_START=1   # TODO figure this out for the general case.
        local KEY_WIDTH=${#KEY_HDR}
        ((KEY_WIDTH++))

        # Chop off the key column. FIXME: Currently assumes it's the first even though that isn't always the case.
        characterCounter=""
        for i in {1..10}; do
            characterCounter+="????????????????????"
        done
        FOLDED_RESULT=$'\n'$resultSet
        FOLDED_RESULT=${FOLDED_RESULT//$'\n'${characterCounter:1:$KEY_WIDTH}/$'\n'}

        # Fold the rest of the result string: (1) hide the spaces and change pipes to spaces so we can fold easily, (2) fold, and (3) reset the spaces and pipes.
        # It was determined experimentally that this method involving two "tr" calls is much faster
        # for medium-to-large result sets than using two pairs of bash-builtin search-and-replacement operations.

        FOLDED_RESULT=$(echo "$FOLDED_RESULT" | tr ' |' '| ' | fold -sw $((COLUMNS-KEY_WIDTH)) | tr '| ' ' |')

        # Useful recipe for a generic right-hand-side cut. You need to supply the field width; note the "${}":
        #printf -v FOLDED_RESULT "%${}s\n" ${FOLDED_RESULT//$'\n'${characterCounter:1:$KEY_WIDTH}/$'\n'}

        # TODO Eventually we should address the problem of the key column not always being the first column.
        # TODO In that case, assuming we want to fold in the first place (we can make that optional with a user option "dontFold | raw | <etc.>")
        # TODO its probably best to pre-adjust the SELECT_CLAUSE before invoking the db engine to get a resultSet that's as easy as possible to manipulate, and
        # TODO then tweak it to the intended result. That's because to do all the manipulation right here is pretty tricky if the key column is sitting in the middle
        # TODO and we want to leave it in place on the first folded chunk of results (if it fits there) while displaying it **first** on the subsequent folded chunks.
        # TODO So let's propose a scheme where we've pre-adjusted it by putting the key column first and some placeholder in the key column's user-intended position.
        # TODO Meanwhile, we'll retain our use of two row-major arrays, one for the key column and one for the rest of the result set, so the for-loop
        # TODO that prints everything can print as follows, line-by-line:    ${left side of main block} ${key block} ${right side of main block}.
        # TODO All we have to do is compensate for the placeholder in the main block by deleting the spaces and one of the field separators around it.

    fi

    # Array-ify
    declare -a FOLDED_ARR
    declare -a KEY_ARR
    OLDFS="$IFS"; IFS=$'\n'
    FOLDED_ARR=($FOLDED_RESULT)
    KEY_ARR=($(cut -c2-$KEY_WIDTH <<< "$resultSet"))  # TODO instead of cut, use a ${foo//???????/} construction (i.e. delete chars)
    local numFoldedLines="${#FOLDED_ARR[@]}"
    IFS="$OLDFS"

    # Print the contents in the right order (not the given order)
    local phaseShift currentLine
    local numRawLines=$(echo "${resultSet:$KEY_WIDTH}" | wc -l) # TODO instead of wc -l, use countChars($'\n')
    local numSections=$((numFoldedLines / numRawLines))

    # Proceed section by section
    for ((phaseShift=0; phaseShift<$numSections; phaseShift++)); do

        # Print key header and column header
        finalResult+="${KEY_ARR[0]}${FOLDED_ARR[$phaseShift]//|/}$newLine"

        # Print all following key rows and result rows plus a blank line
        currentLine=$phaseShift
        for ((lineIdx=1; lineIdx<$numRawLines; lineIdx++)); do
            ((currentLine+=numSections))
            finalResult+="${KEY_ARR[lineIdx]}${FOLDED_ARR[$currentLine]//|/$newLine}"
        done
        finalResult+=$newLine
    done

    setReturnValue "$finalResult"
    return ${rc[SUCCESS]}
}


