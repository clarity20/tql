# vim:filetype=sh:fdm=marker:

# build_functions: Software infrastructure to construct SQL code given a fully marked-up
# input string consisting of a single ((name)-comparator)-value predicate or expression
# in the abbreviated syntax of TQL.

if ((g_sourcedGlobals!=1)); then
    source tql_globals
    g_sourcedGlobals=1
fi

# We define operator strength as the inverse of operator precedence:
# the strongest operators are those that can be "seen" from the greatest distance
declare -A g_operatorStrength
g_operatorStrength=(

# arithmetic operators
["/"]=1
["*"]=1
["%"]=1
["+"]=2
["-"]=2

# bitwise operators
["^"]=0
["<<"]=3
[">>"]=3
["&"]=4
["|"]=5

# comparators
["="]=6
["!="]=6
[">"]=6
["<"]=6
[">="]=6
["<="]=6
["<>"]=6
["<=>"]=6

# assignment operator
[":="]=7
)

# Enumerate the ways in which the resultant data types of complex expressions
# can be deduced from their operators and the types of their operands.
# We partition this information in two data structures according to whether
# or not the operator is a comparator.

# For comparator expressions we list the permissible forms in a simple array.
# Each entry specifies a permissible form or set of forms: a first type,
# the operator(s) and a second type.
# We use regular expressions to shorten the overall list, and in the code
# we blanket-permit every form in which both types are the same.
declare -a g_compTypeResolutions
declare -r regex_equalOrNot="^(\!?=|<=?>)$"      # will match any of  !=  =  <>  <=>
g_compTypeResolutions=(
"${tt[INTEGER]}${regex_equalOrNot}${tt[INT_LIST]}"
"${tt[INTEGER]}${regex_equalOrNot}${tt[FLOAT_LIST]}"
"${tt[INTEGER]}${regex_equalOrNot}${tt[PREFIX_LIST]}"
"${tt[INTEGER]}${regex_equalOrNot}${tt[INT_RANGE]}"
"${tt[FLOAT]}${regex_equalOrNot}${tt[FLOAT_LIST]}"
"${tt[STRING_CONSTANT]}${regex_equalOrNot}${tt[REGEX_LIST]}"
"${tt[DATE]}${regex_equalOrNot}${tt[DATE_RANGE]}"
)

# For non-comparator expressions we use a key-value scheme. The keys consist of
# a type, operator(s) (optionally), and another type, and the values hold the resultant type.
# When the operator is omitted we are indicating that the relation applies irrespective of the operator.
# We use a regular expression to denote an arbitrary operator where appropriate.
declare -A g_opTypeResolutions
declare -r regex_anyOperator=".*"
g_opTypeResolutions=(
[${tt[INTEGER]}${regex_anyOperator}${tt[INTEGER]}]=${tt[INTEGER]}
[${tt[DECIMAL]}${regex_anyOperator}${tt[DECIMAL]}]=${tt[DECIMAL]}
[${tt[INTEGER]}${regex_anyOperator}${tt[DECIMAL]}]=${tt[DECIMAL]}
[${tt[DECIMAL]}${regex_anyOperator}${tt[INTEGER]}]=${tt[INTEGER]}
[${tt[DATE]}"+"${tt[INTEGER]}]=${tt[DATE]}
)

####################################################################################
# evaluateTree (parsedTQLexpression [, currentNestingLevel])
#
# Traverses the parse tree of a TQL expression level-by-level in order of
# operator precedence so that "smart" type analysis can be performed.
# This function will evaluate the tree for a single choice of word expansions.
# The choice is denoted by an array of indices at caller scope. (This is bash,
# after all.) Typically, the caller will set these indices before invoking
# this function or iterate over them and call this function repeatedly.
####################################################################################
function evaluateTree()
{
    local expression=$1 currentLevel=${2:-0}
    declare -i retVal
    local leftType rightType
    local operatorToken="${tokenDelimiter}[0-9]+([${tt[COMPARATOR]}${tt[OPERATOR]}])$currentLevel([^${tokenDelimiter}]+)"
    local spaceToken=${tokenDelimiter}${tt[SPACE]}
    local leftParenToken=${tokenDelimiter}[0-9]+${tt[LEFT_PAREN]}[0-9]+
    local rightParenToken=${tokenDelimiter}[0-9]+${tt[RIGHT_PAREN]}[0-9]+

    # Find the "strongest" operator at the current level; divide there and recurse down both sides
    local tempExpr=$expression
    local currOperator operator operatorType leftSide rightSide
    declare -i currStrength maxStrength
    while [[ "$tempExpr" =~ ${operatorToken}(.*) ]]; do   # N.B. first parts of BASH_REMATCH are hidden in $operatorToken
        currOperator=${BASH_REMATCH[2]}

        # Heart of the maximization algorithm: Is the operator the strongest so far (or at least a tie)?
        currStrength=${g_operatorStrength[$currOperator]}  # Look up the operator "strength"
        if ((currStrength >= maxStrength)); then      # Compare with >= to favor equal operators further to the right;
                                                      # this enforces left-associativity.
            maxStrength=$currStrength

            # Record the splitting information
            leftSide=${expression%${BASH_REMATCH[0]}}
            operator=$currOperator
            operatorType=${BASH_REMATCH[1]}
            rightSide=${BASH_REMATCH[3]}
        fi

        tempExpr=${BASH_REMATCH[3]}
    done

    # If an operator was found ...
    if ((maxStrength > 0)); then

        ######
        # On both sides, clean up parenthesized subexpressions, recurse downward,
        # and evaluate based on the finer-grained results
        ######

        # Left side: Check for parenthesization
        if [[ $leftSide =~ (${spaceToken})*${leftParenToken}(.*)${rightParenToken}(${spaceToken})* ]]; then
            # If it is parenthesized, strip the parens and evaluate the left side at the next nesting level
            leftSide=${BASH_REMATCH[2]}
            evaluateTree "$leftSide" $((currentLevel+1)); leftType=$g_returnString
        else
            # If it is not parenthesized, evaluate the left side at the same level
            evaluateTree "$leftSide" $currentLevel; leftType=$g_returnString
        fi

        # If the expression is known to be invalid, jump up and out
        if [[ $leftType == ${tt[INVALID_TYPE]} ]]; then
            return $leftType
        fi

        # Repeat the above for the right side
        if [[ $rightSide =~ (${spaceToken})*${leftParenToken}(.*)${rightParenToken}(${spaceToken})* ]]; then
            rightSide=${BASH_REMATCH[2]}
            evaluateTree "$rightSide" $((currentLevel+1)); rightType=$g_returnString
        else
            evaluateTree "$rightSide" $currentLevel; rightType=$g_returnString
        fi
        if [[ $rightType == ${tt[INVALID_TYPE]} ]]; then
            return $rightType
        fi

        # Combine the types using the operator
        lookupResultantType $leftType $operator $operatorType $rightType
        return        # g_returnString will have just been set

    else # No operator was found at the current level. This means we are left with either
        # a function call, a solitary token of expandable type, or a primitive constant.
        # Determine which of these holds by looking at the token type indicator.
        local tokenNumber tokenType tokenValue
        [[ "$expression" =~ ^${tokenDelimiter}([0-9]+)([^0-9])(.*) ]]
        tokenNumber=${BASH_REMATCH[1]}
        tokenType=${BASH_REMATCH[2]}
        tokenValue=${BASH_REMATCH[3]}

        case $tokenType in
            ${tt[FUNCTION]})
                # Recurse on the arguments to get their resolvent/aggregate types.
                # Combine that with the function arity to look up the function and see its type.
                #TODO Coming soon.
                ;;
            ${tt[EXPANDABLE_WORD]})
                # Retrieve the type of the word from the candidate list.
                # The token number tells us which candidate list.
                declare -a columnList
                local tempLine sqlType
                for ((i=0; i < columnCount; i++)); do
                    if ((tokenNumber == columnTokenIDs[i])); then
                        tempList=(${columnLists[i]})
                        tempLine=${tempList[listIndices[i]]}
                        # Parse out the RDBMS type, convert to an internal type and return it
                        [[ "$tempLine" =~ $delim2(.*)$delim2 ]]
                        sqlType=${BASH_REMATCH[1]}
                        sqlTypeToInternalType "$sqlType"
                        return 0 # $g_returnString will have been set
                    fi
                done
                ;;
            ${tt[EXPANDABLE_SEQUENCE]})
                #TODO Coming soon.
                ;;
            default)
                # Any "normal" single token
                g_returnString=$tokenType
                return 0
                ;;
        esac
    fi

    return $ERR_INVALID_TYPE
}

####################################################################################
# sqlTypeToInternalType (sqlType)
#
# Converts a SQL data type to an internal data type that captures distinctions of
# interest and disregards the rest. The purpose is to map data types we can read
# off the DB schema to patterns we can recognize with plain pattern matching
# as with the internal token-typing system.
#
# N.B. To support additional RDBMS this function will need to be updated.
# N.B. We choose to represent even data types we do not intend to implement.
####################################################################################
function sqlTypeToInternalType()
{
    local sqlType=${1,,}

    # Note carefully which comparisons use the "==" sign and which use the "=~"
    if [[ "$sqlType" =~ (int|^bool|^bit|^year) ]]; then
        g_returnString=${tt[INTEGER]}
    elif [[ "$sqlType" =~ (char|binary|enum) ]]; then   # char, varchar, binary
        g_returnString=${tt[STRING_CONSTANT]}
    elif [[ "$sqlType" =~ (^dec|^num|^double|^float|^fix) ]]; then
        g_returnString=${tt[DECIMAL]}
    elif [[ "$sqlType" == date ]]; then
        g_returnString=${tt[DATE]}
    elif [[ "$sqlType" == time ]]; then
        g_returnString=${tt[TIME]}
    elif [[ "$sqlType" =~ time ]]; then   # datetime and timestamp
        g_returnString=${tt[TIMESTAMP]}
    elif [[ "$sqlType" =~ (blob|text) ]]; then
        g_returnString=${tt[BLOB]}
    elif [[ "$sqlType" == set ]]; then
        g_returnString=${tt[SET]}
    else
        g_returnString=${tt[INVALID_TYPE]}
    fi
}

####################################################################################
# lookupResultantType (type1, operator, operatorType, type2)
#
# Determines the resultant type of a binary operation applied to two objects
# of the specified types, or returns an error code if the operation is not valid
####################################################################################
function lookupResultantType()
{
    declare -r type1=$1 operator=$2 operatorType=$3 type2=$4
    local resultantType=${tt[INVALID_TYPE]}
    local typeSchematicIndex

    if [[ $operatorType == ${tt[COMPARATOR]} ]]; then
        # Like types can always be compared. With the following shortcut, we avoid
        # having to enumerate every combination of type and comparator separately.
        if [[ "$type1" == "$type2" ]]; then
            resultantType=${tt[INTEGER]}

        # Other expressions involving comparators need to be looked up in
        # the enumerative list.
        else
            typeSchematicIndex=$type1$operator$type2
            declare -i i;     #TODO Move to tql_globals. Add a "j" too.
            # Look for the above schematic among the array elements.
            # The array is small, so linear search is fast enough.
            for ((i=0; i < ${#g_compTypeResolutions}; i++)); do
                if [[ "$typeSchematicIndex" =~ ^${g_compTypeResolutions[$i]}$ ]]; then
                    resultantType=${tt[INTEGER]}
                    break
                fi
            done
        fi

    else
        # Lookup the resultant type for this type schematic
        typeSchematicIndex=$type1$operator$type2
        resultantType=${g_opTypeResolutions[$typeSchematicIndex]}
        # If there is no type for this schematic, look for a general schematic that fits
        if [[ -z $resultantType ]]; then
            typeSchematicIndex=$type1$regex_anyOperator$type2
            resultantType=${g_opTypeResolutions[$typeSchematicIndex]}
        fi
        # An empty / nonexistent result indicates an illegal operation
        : ${resultantType:=${tt[INVALID_TYPE]}}
    fi

    g_returnString=$resultantType
}

