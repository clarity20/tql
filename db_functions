# vim: set filetype=sh:

# Set some essential variables
: ${BASHFUNC_HOME:=$HOME}
: ${TQL_HOME:=$HOME/tql}
# Override the PATH with the locations of this project installation and your GNU/Linux coreutils
# TODO Clarify which versions of which utilities are required. Verify POSIX compatibility.
PATH=$TQL_HOME:$BASHFUNC_HOME/bin:/usr/local/bin:/usr/bin

# Enable extended file globbing. This allows us to write shorter, simpler code in a few places.
shopt -s extglob

# Load the universal TQL constants
if ((g_sourcedGlobals!=1)); then
    source $TQL_HOME/tql_globals
    g_sourcedGlobals=1
fi

# TODO Phase this out; bring isArgOfType into the main code
source $TQL_HOME/script_functions

source $TQL_HOME/expand_functions

# TODO Consider introducing some variable naming conventions for better readability
# and to minimize shadowing bugs.
# (1) Use the prefix g_ to mean "global".
# (2) Use the form "_varName_funcAbbr" for variables local to the indicated function
#     and everything lower in the call stack, and used in both.

declare -r delim=$'\n'
declare -r delim2=$'\f'
declare -r ILLEGAL_DEFAULT_ALPHA=illegalDefaultAlpha
declare -r ILLEGAL_DEFAULT_NUM=illegalDefaultNum
declare -r placeholderForEmpty=" "
declare -r defaultAction=SELECT
declare -r setClauseMarker="@"
declare -r updateOperator=':='
declare -r MIN_VALUE_LEN=1       # min/max length of values supplied on the command line
declare -r MAX_VALUE_LEN=1024

# Syntax for indicating filenames (or stdin) as data sources
declare -r embeddedFileRegex="@(.*)@"

# Assign defaults for values used in many caller scripts
g_defaultNums=$ILLEGAL_DEFAULT_NUM
g_defaultNumCodes=0i
g_defaultAlnums=$ILLEGAL_DEFAULT_ALPHA
g_defaultAlnumCodes=qa
g_ACTION=$defaultAction
# Enable a warning message when a query would return the full table. Intended for large tables.
g_warnOnSelectAll=$TRUE

g_dbClientOptions=""
g_mainConjunction=AND
g_haveParser=$FALSE

# The reference data description used to expand abbreviated table or column names
g_masterColumnList=""


##############################################################################################
# parseCompletely  standardColumns  tables  mainColumn  wherePreclause  <full sqlUtil cmd line>
# Wraps up the argument parsing engine in a single function, enabling thinner client scripts
# Return code: 0 for select queries, 1 for updates, 10 or greater for errors
##############################################################################################
function parseCompletely()
{
    # Values to be set and returned
    local OPTIONS
    local STANDARD_COLS="$1"
    local TABLES="$2"
    local mainColumn="$3"
    local WHERE_PRECLAUSE="$4"

    # Constant ("enumerated") internal error codes
    declare -r retCode_noSelection=0
    declare -r retCode_selectMainColumnOnly=1
    declare -r retCode_clearAllSelections=2
    declare -r retCode_ordinarySelection=3

    shift 4

    local remainingArgs

    # Filter the command-line options into a separate list
    parseOutOptions "$@"
    if (($?)); then
        getReturnValues OPTIONS remainingArgs
        eval set "-- "$remainingArgs
    fi

    # Load the expression parser
    if [[ $g_haveParser == $FALSE ]]; then
        g_haveParser=$TRUE
        source $TQL_HOME/parse_functions
    fi

    # If the UPDATE option is active, prepare the SET clause
#TODO Instead of bIsUpdate we should use an "enumeration" / function getQueryType to indicate the query type.
#TODO A 0/1 indicator is not adequate when we introduce DELETE or INSERT queries.
# So, for example:
#    getQueryType; queryType=$?
#   if ((queryType == queryType_UPDATE)); then
#       ....
#   fi
#
    isOptionOn u $OPTIONS
    bIsUpdate=$?
    if ((bIsUpdate)); then
        parseOutSets "$@"
        if (($?)); then
            getReturnValues SET_CLAUSE setAbbrs remainingArgs
            eval set "-- "$remainingArgs
        else
            echo Error: The UPDATE flag is set without any UPDATE instructions.
            return 15
        fi
    elif [[ "$@" =~ $updateOperator ]]; then
        echo Error: An UPDATE instruction was detected but the update flag was not set.
        return 16
    fi

    # Extract the column selection modifiers from the command line
    parseOutSelects "$@"
    retVal=$?
    if ((retVal)); then  # some SELECT-type arguments were detected

        # If it's not an UPDATE query, prepare the SELECT clause
        if ((bIsUpdate)); then
            echo Error: Both SELECT and UPDATE commands were detected.
            return 17
        fi

        # Parse out the returned values
        getReturnValues rawPreselects rawPostselects remainingArgs
        eval set "-- "$remainingArgs
        if [[ $rawPreselects == " " ]]; then rawPreselects=; fi     ## old way was to use backticks so " " became ""
        if [[ $rawPostselects == " " ]]; then rawPostselects=; fi
    fi

    # If required, make special adjustments to the standard column set
    case $retVal in
        $retCode_clearAllSelections)   STANDARD_COLS="" ;;
        $retCode_selectMainColumnOnly) STANDARD_COLS=$mainColumn ;;
        *) isOptionOn selectAll $OPTIONS
           if (($?)); then
               STANDARD_COLS="*"
           fi ;;
    esac

    # Pass any special options to the db client
    g_dbClientOptions=""
    isOptionOn noHeader $OPTIONS
    if (($?)); then g_dbClientOptions+="-N "; fi

#TODO We defer where-expanding to generateWhereClause
#    # Get the column names from the where-particles
#    getWhereColumnList "$@"
#    whereAbbrs=$g_returnString

    # Expand the abbreviated names unless directed otherwise
    isOptionOn "dontExpand|de" $OPTIONS
    if (($?)); then
        # Assemble the full SELECT clause from the three parts without expanding
        assembleSelectClause "$rawPreselects" "$STANDARD_COLS" "$rawPostselects"
        getReturnValue ACTION_CLAUSE
    else
        # To make things easier, come up with a list of table names *without* aliases
        TABLE_NAMES=${TABLES//+( )+([[:alpha:]])*( ),*( )/,}     # in two steps, squeeze out table-name aliases "myTable mt," leaving just the table names
        TABLE_NAMES=${TABLE_NAMES/%+( )+([[:alpha:]])}

        # Obtain the table description so we can expand the column names and determine their data types
        # TODO This looks at the first table name only.  Might revisit this later. N.B. expand() requires a fixed-width Desc, so catting
        # TODO the separate desc files together would not work. Perhaps make Desc adjust its column-width values whenever a header line is encountered...
        loadTableDescription ${TQL_SCHEMA_CACHE:-$TQL_HOME/tableDesc/${TABLE_NAMES%%,*}}

#TODO Defer where-expanding to generateWhereClause
#        # Expand the WHERE clause column names
#        expandColumnNames "$TABLE_NAMES" "$whereAbbrs"
#        expandedNames=$g_returnString
#        expandedWhereCols=${expandedNames%$delim*}
#        whereCodes=${expandedNames#*$delim}

        if ((bIsUpdate)); then
            # Expand the SET clause column names and finish off the clause itself
#MMMM Address the side effect of reworking expand():
            expandColumnNames "$TABLE_NAMES" "$setAbbrs"
            getReturnValue setCols setCodes
            OLDFS="$IFS"; IFS=$',' expandedSetCols=(${setCols})

            local nullPlaceholder=$setClauseMarker$NULL_INDICATOR$setClauseMarker
            for nextColumn in ${expandedSetCols[@]}; do
                nextAbbr=${setAbbrs%%,*}; nextCode=${setCodes%%,*}

                # If it's a null marker, put "NULL" in its place
                if [[ "$SET_CLAUSE" =~ ^[^$setClauseMarker]*$nullPlaceholder ]]; then
                    SET_CLAUSE=${SET_CLAUSE/$nullPlaceholder/NULL}

                # Else quote the value if necessary
                elif [[ $nextCode =~ ^q ]]; then
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/\'}
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/\'}

                # Else remove the markers from the value
                else
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/}
                    SET_CLAUSE=${SET_CLAUSE/$setClauseMarker/}
                fi

                SET_CLAUSE=${SET_CLAUSE/$nextAbbr/$nextColumn}
                setAbbrs=${setAbbrs#$nextAbbr,}; setCodes=${setCodes#$nextCode,}
            done
            IFS="$OLDFS"
            SET_CLAUSE="SET "$SET_CLAUSE

        else
            # Expand the SELECT clause column names, keeping track of the pre/post distinction
            expandSelections "$rawPreselects"; getReturnValue preselects
            expandSelections "$rawPostselects"; getReturnValue postselects

            # Assemble the full SELECT clause from the three parts
            assembleSelectClause "$preselects" "$STANDARD_COLS" "$postselects"
            getReturnValue ACTION_CLAUSE
        fi
    fi

    if ((! bIsUpdate)); then
        # Check for empty SELECT clause. (Should only be possible if "00" option is invoked.)
        if [[ ! "$ACTION_CLAUSE" =~ [[:alnum:]*] ]]; then
            echo ERROR: Your column selection is empty. Please select some columns. > /dev/stderr
            return 10
        fi
    fi

    # Build the core WHERE-clause by lexing, parsing and expanding the arguments and translating to SQL.
#TODO Defer (etc.):
#    generateWhereClause "$expandedWhereCols" "$whereCodes" "$@"
    generateWhereClause "$@"
    retVal=$?
    case $retVal in
      2) echo Parsing error: Unrecognized argument.
         return $((retVal+10)) ;;
      1) echo Incorrect calling syntax.
         return $((retVal+10)) ;;
      *) # Parsing was successful.
         ;;
    esac
    getReturnValues WHERE_CLAUSE sortInstructions

    # Massage the query contents based on the user options
    # -- By default, use NULLs "intuitively" inside NOT-subclauses rather than using SQL's built-in 3-valued-logic
    isOptionOn "trueNull|tn" $OPTIONS
    if (($? == 0)); then
        if [[ "$WHERE_CLAUSE" =~ NOT ]]; then
            useIntuitiveNulls "$WHERE_CLAUSE"
            getReturnValue WHERE_CLAUSE
        fi
    fi

    WHERE_CLAUSE="${WHERE_CLAUSE/# $g_mainConjunction/WHERE}"     ## need to do this for every custom script where the WHERE_PRECLAUSE is empty
    if [[ (! $WHERE_CLAUSE =~ ^WHERE) && ($WHERE_CLAUSE =~ [[:alpha:]]) ]]; then
        WHERE_CLAUSE="WHERE $WHERE_CLAUSE"
    fi
    if [[ "$WHERE_CLAUSE" =~ illegalDefault ]]; then
        if [[ "$WHERE_CLAUSE" =~ $ILLEGAL_DEFAULT_ALPHA ]]; then
            echo FAIL: Cannot infer a column name for pure alphabetic or regex arguments.
        elif [[ "$WHERE_CLAUSE" =~ $ILLEGAL_DEFAULT_NUM ]]; then
            echo FAIL: Cannot infer a column name for pure numeric arguments.
        fi
        return 13
    fi

    # Construct the LIMIT clause
    isOptionOn "l[0-9]+" "$OPTIONS" -show; getReturnValue LIMIT_CLAUSE
    if [[ -n "$LIMIT_CLAUSE" ]]; then
        LIMIT_CLAUSE="LIMIT "${LIMIT_CLAUSE#[Ll]}
    fi
    : ${LIMIT_CLAUSE:=$placeholderForEmpty}

    # If the WHERE clause is effectively empty, provide a warning before returning an unrestricted result set
    if [[ ( $WHERE_CLAUSE == $placeholderForEmpty ) && ( ! $LIMIT_CLAUSE =~ [1-9] ) && ( ! $ACTION_CLAUSE =~ "count(*)" ) && ( $g_warnOnSelectAll == 1 ) ]]; then
        echo WARNING: Query is unrestricted, every record will be returned! > /dev/stderr
        read -n1 -p "Continue (y/n)? " doContinue > /dev/stderr
        echo > /dev/stderr
        if [[ ! $doContinue =~ ^[Yy]$ ]]; then
            echo Query cancelled.
            return 14
        fi
    fi

    setReturnValues "$OPTIONS" "${SET_CLAUSE:-$ACTION_CLAUSE}" "$WHERE_CLAUSE" "$LIMIT_CLAUSE" "$sortInstructions"

    return $bIsUpdate
}

####################################################################################
# assembleSelectClause  <prefix>  <infix>  <suffix>
#
# Assembles the select clause from the three parts provided,
# inserting commas only where appropriate
####################################################################################
function assembleSelectClause()
{
    local selectClause
    local preselects=$1
    local standardColumns=$2
    local postselects=$3

    selectClause=$preselects
    if [[ -n $selectClause && -n $standardColumns ]]; then
        selectClause+=,
    fi
    selectClause+=$standardColumns
    if [[ -n $selectClause && -n $postselects ]]; then
        selectClause+=,
    fi
    selectClause+=$postselects

#MMMM Temp fix: strip out all of the markup tags, leaving a pure SELECT clause
#MMMM This means the delims, token counts and type indicators. (But for NCV delims there are no counts.)
    selectClause=${selectClause//$tokenDelimiter?/}

    setReturnValue "$selectClause"
}

####################################################################################
# expandSelections  <list of selections>
#
# Expands a delimited list of SELECT expressions.
####################################################################################
function expandSelections()
{
    local rawSelections=$1

    local selectionDelimiter=$tokenDelimiter${tt[DELIMITER]}"0" # 0 assumes the delimiters have no enclosing parens
    local tokenizedSelections completeExpansion currentSelection expandedSelection

    # Tokenize the (comma-delimited) list of selections
    parseQueryClause "$rawSelections"; getReturnValue tokenizedSelections

    # Handle the selections one-by-one. Each can contain one or more expandable words.
    completeExpansion=""
    while [[ -n $tokenizedSelections ]]; do

        # Pull the next selection from the selection list
        if [[ $tokenizedSelections =~ $selectionDelimiter(.*) ]]; then
            currentSelection=${tokenizedSelections%${BASH_REMATCH[0]}}
            tokenizedSelections=${BASH_REMATCH[1]}
        else
            currentSelection=$tokenizedSelections
            tokenizedSelections=""
        fi

        # Cycle through the abbreviated words within the current selection
        # to construct a new selection in which all words have been expanded
        #TODO We will eventually modify this loop to accumulate the lists of expansion candidates
        #TODO before we prune them down through semantic analysis of the parse tree.
        #TODO Right now, we are rolling out the architecture that enables us to accumulate them.
        expandedSelection=""
        local tokenPrefix expansionType currentAbbr unexpandablePrefix
        while [[ $currentSelection =~ ($tokenDelimiter[0-9]+)([$g_expandableTypes])([^$tokenDelimiter]+)(${tokenDelimiter}.*|$) ]]; do
            tokenPrefix=${BASH_REMATCH[1]}
            expansionType=${BASH_REMATCH[2]}
            currentAbbr=${BASH_REMATCH[3]}
            unexpandablePrefix=${currentSelection%${BASH_REMATCH[0]}}
            currentSelection=${BASH_REMATCH[4]}

            case $expansionType in
                ${tt[EXPANDABLE_WORD]})
                    getExpandedColumnNames "$TABLE_NAMES" $currentAbbr; getReturnValue expansionCandidates
                    promptForExpansion "$currentAbbr" "$expansionCandidates"
                    getReturnValues expandedName internalType
                    ;;
                ${tt[EXPANDABLE_SEQUENCE]})
#MMMM Needs finishing:
                    expandSequence "$currentAbbr"
                    getReturnValue expandedName
                    ;;
                ${tt[FUNCTION]})
#MMMM Needs finishing:
                    getExpandedFunctionNames "$TABLE_NAMES" $currentAbbr; getReturnValue expansionCandidates
                    promptForExpansion "$currentAbbr" "$expansionCandidates"
                    getReturnValues expandedName internalType
                    #MMMM finalizeExpandedFunctionName $expandedName
                    ;;
            esac

            # Piece together the expanded string
            expandedSelection+=$unexpandablePrefix$tokenPrefix$expansionType$expandedName
        done

        # The selection is fully expanded. If there is a trailing literal piece, attach it
        if [[ -n $currentSelection ]]; then
            expandedSelection+=$currentSelection
        fi
        completeExpansion+=$expandedSelection,
    done
    completeExpansion=${completeExpansion%,}

    setReturnValue "$completeExpansion"
}


####################################################################################
# useIntuitiveNulls
# Alters a fully-constructed WHERE clause so as to imitate a user-friendly 2-valued logic
# in place of SQL's 3-valued logic; IOW, allows NULL values to pass not-equal checks against
# non-NULL values. If the "trueNull" option is set, the caller AVOIDs this function.
####################################################################################
function useIntuitiveNulls()
{
    # Divide the given WHERE clause at the "NOT (" if it exists
    local lhs="${1%%NOT (*}"
    local rhs="${1#$lhs}"

    # Walk the given WHERE-clause for NOT-subclauses we need to change
    while [[ $rhs =~ ^NOT\  ]]; do

        # The first goal is to correctly and exactly identify the next NOT subclause.
        # We are working with three forms of NOT subclauses; observe they might or might not make provisions for "NULL".
        #     (1) NOT (x = value    [OR ... OR    y = value] [ OR x IS NULL])
        #     (2) NOT (x LIKE 'rgx' [OR ... OR y LIKE 'rgx'] [ OR x IS NULL])
        #     (3) NOT (x IN (list)  [OR ... OR  y IN (list)] [ OR x IS NULL])

        # Find the ")" character that closes the NOT clause.
        # For cases (1),(2) we can just chop at the first ")" since they will never have internal parentheses
        local notClause=${rhs%%)*}")"

        # For case (3), the preceding is not correct because of the internal parentheses
        if [[ $notClause =~ \(.*\( ]]; then
            # Extend the NOT clause to the terminating "))" or "NULL)", whichever is nearer. Choose by chopping the string both ways and measuring.
            # Note: If the applicable terminating sequence is all the way at the end, then the chopped pieces will have equal length. Careful!
            local toNextParens=${rhs%%\)\)*}
            local toNextNULL=${rhs%%NULL\)*}
            ((lengthDiff=${#toNextNULL}-${#toNextParens}))
            if [[ ( $lengthDiff -gt 0 ) || ( $lengthDiff -eq 0 && $toNextParens =~ \)\) ) ]]; then
                notClause=$toNextParens"))"
            else
                notClause=$toNextNULL"NULL)"
            fi
        fi

        # Skip this NOT clause if it already takes "nullness" into account
        if [[ $notClause =~ NULL ]]; then
            lhs+=$notClause         # increase
            rhs=${rhs#$notClause}   # shrink

        # Update the NOT clause by allowing NULLs as appropriate.
        else
            # Every column listed in the NOT-clause should explicitly allow NULLs, since we're simulating "intuitive" NULLs
            # and we're currently inside a "NOT". Also, observe that the NOT-clause will contain just one column
            # unless it was constructed by iterating over default{Num,Alnum}Cols. So to get the full column list,
            # we check whether the last column name differs from the first, and if so
            # we'll iterate over default{Num,Alnum}Cols; otherwise we just take the first column name we see.

            local originalNotClause=$notClause

            # Parse out the first column name
            [[ $notClause =~ \(([^ ]*)\ (LIKE|IN|=)(.*) ]]
            firstColumnName="${BASH_REMATCH[1]}"

            # Is the NOT clause a compound clause?
            if [[ $notClause =~ \ OR\  ]]; then

                # Parse out the last column name
                [[ $notClause =~ ([^ ]*)\ (LIKE|IN|=)\ [^\ ]*$ ]]
                lastColumnName="${BASH_REMATCH[1]}"

                local columnList
                if [[ $firstColumnName == $lastColumnName ]]; then
                    columnList=$firstColumnName
                elif [[ $g_defaultAlnums =~ $firstColumnName.*$lastColumnName ]]; then
                    columnList=$g_defaultAlnums
                else
                    columnList=$g_defaultNums
                fi

                # Make the key addition(s) to the NOT-subclause
                notClause="("$notClause
                OLDFS="$IFS"; IFS=$','
                for columnName in $columnList; do
                    $notClause+=" OR ${columnName%%:*} IS NULL"       # chop off any special indicators appended to the columnName
                done
                notClause+=")"
                IFS="$OLDFS"

            # Otherwise the NOT subclause is a simple clause and we have only one column name
            else
                notClause="("$notClause
                notClause+=" OR "$firstColumnName" IS NULL)"
            fi

            # Update lhs/rhs for the next iteration: substitute in the modified NOT subclause
            # and advance to the next NOT subclause if there is one
            lhs+=$notClause
            rhs=${rhs#$originalNotClause}
        fi

        # When there are no more NOT clauses, finalize the string and break the loop
        if [[ ! rhs =~ ^NOT\  ]]; then
            lhs+=$rhs
            break
        fi
    done

    # End of function.
    setReturnValue "$lhs"
}

###################################################################################
# isOptionOn/Off  option  optionSet  [-show]
# Looks for the specified option(s) in the (colon-delimited and -surrounded) optionSet
###################################################################################
function isOptionOn()
{
    local regex=":($1):"

    if [[ "${2,,}" =~ ${regex,,} ]]; then   # Lowercase-ify the arg and the regex to get case-agnosticism
        if [[ "$3" == -show ]]; then
            setReturnValue "${BASH_REMATCH[1]}"
        fi
        return 1
    else
        return 0
    fi
}

function isOptionOff()
{
    isOptionOn "$@"
    return $(( ! $? ))
}

##########################################################################################
# parseOutOptions  command_line...
# Given a set of arguments, this function constructs and returns two strings in one:
#  (1) A colon-delimited string listing the OPTIONS detected. These are the arguments that begin
#      with a "-" sign, plus the special "*" option which we encode as 'selectAll'.
#  (2) A symbolic list of the args that are not options, e.g. if $1 and $4 are not options, then
#      this string will be set to "${1} ${4}" (where all characters between quotes are literal).
#      This enables the caller to easily remove the option arguments from his command line
#      by calling the "set" builtin.
# Return code = number of option arguments detected
##########################################################################################
function parseOutOptions()
{
    local OPTION_LIST retArgs retCode
    local optionsRegex="(^| )(-|[*]( |$))"
    local arg nextArg

    # Quick exit if there are no options
    if [[ ! "$@" =~ $optionsRegex ]]; then return 0; fi

    for ((idx=1; idx<=$#; idx++)); do
        eval arg=\$$idx      # value of the idx-th argument ($idx is just the index number)

        # Identify the "normal" option arguments; "-" plus the option name and sometimes a value
        if [[ "$arg" =~ ^[-]+[[:alnum:]] ]]; then

            # For options having settable values we accept 3 forms:  -op=Val  -opVal  or  -op Val
            arg=${arg/=/}                         # Squeeze out the = sign
            if [[ $arg =~ ^[-]+[Ll]$ ]]; then        # Squeeze out the space, i.e. add the following argument
                ((++idx))
                eval newArg=\$$idx
                if [[ ! $newArg =~ ^[0-9]+$ ]]; then
                    echo Error: Limit must be numeric. > /dev/stderr
                    exit 20
                fi
                arg+=$newArg
            fi

            # Add the option to the internal list
            OPTION_LIST+=":"${arg##+(-)}
            ((retCode++))

        # Interpret the special "*" argument as the selectAll option
        elif [[ "$arg" == "*" ]]; then
            OPTION_LIST+=":selectAll"
            ((retCode++))

        # Otherwise the argument is not an option.
        else
            retArgs+='"${'$idx'}" '
        fi
    done

    retArgs="${retArgs% }"

    # Make the options case-agnostic by always storing them in lowercase
    setReturnValues "${OPTION_LIST,,}" $retArgs

    return $retCode
}

##########################################################################################
# expandValueSet  valueSet  valueType
#
# Expands two types of possibly-abbreviated value sets into their full-length equivalents:
#   (1) ranges (numeric or date) --> pairs of interval endpoints
#         e.g.  "100200300-99" --> "100200300 <delim> 100200399"
#               "2013/10-12" --> "2013-10-01 <delim> 2013-12-31"   (use / within dates, - to delimit ranges)
#               "2013/10/5-20" --> "2013-10-5 <delim> 2013-10-20"
#   (2) prefix lists --> normal lists
#         e.g.  "1002003:00,99" --> "100200300,100200399"   (use : after prefix, commas to delimit)
##########################################################################################
function expandValueSet()
{
    local first=${1%[-:]*}
    local second=${1#*[-:]}
    local filler='???????????????'
    declare -r NUM_RANGE=1 DATE_RANGE=2 PREFIX_LIST=3
    local firstArg secondArg response

    if (($2 == NUM_RANGE)); then
        # greater/less than the parsed-out values
        firstArg=$first
        if [[ ${#second} -lt ${#first} ]]; then
            secondArg=${first/%${filler:0:${#second}}/$second}
        else
            secondArg=$second
        fi
        response=$firstArg
        response+=$delim
        response+=$secondArg

    elif (($2 == DATE_RANGE)); then
        # Base the parsing on the slash count before/after hyphen:
        # two before ...
        if [[ $first =~ /[[:digit:]]+/ ]]; then
            firstArg=$first
            # two after ...
            if [[ $second =~ /[[:digit:]]+/ ]]; then
                secondArg=$second
            # one after ...
            elif [[ $second =~ / ]]; then
                secondArg=${first%%/*}/$second
            # none after ...
            else
                secondArg=${first%/*}/$second
            fi
        # one before ...
        elif [[ $first =~ / ]]; then
            firstArg=$first/01
            # one after ...
            if [[ $second =~ / ]]; then
                secondArg=$second/31
            # none after but there is a number ...
            elif [[ $second =~ [0-9] ]]; then
                secondArg=${first%/*}/$second/31
            # second is blank altogether ...
            else
                secondArg=$first/31
            fi
        else
            response="Error in date range."
        fi

        # Turn /'s into -'s for SQL compatibility
        firstArg=${firstArg//\//-}
        secondArg=${secondArg//\//-}

        response=$firstArg
        response+=$delim
        response+=$secondArg

    elif (($2 == PREFIX_LIST)); then
        response=:$second
        response=${response//[:,]/,$first}
        response=${response#,}
    else
        response="Not a range or a prefix list."
    fi

    setReturnValue "$response"
}

##########################################################################################
# parseOutSets  command_line...
#
# Given a list of arguments, this function constructs and returns a pseudo-SET clause for use
# in an UPDATE stmt, where the values are delimited with special markers;
# a comma-list of the (abbreviated) column names in the clause; and a symbolic list of the remaining (non-SET-type) arguments
#
# Note: A SET-type argument is a "name-op-value" tuple where "op" is :=
#
# Returns the number of SET particles detected
##########################################################################################
function parseOutSets()
{
    local SET_CLAUSE abbrList retArgs name value
    declare -i haveSets=0

    for ((idx=1; idx<=$#; idx++)); do
        eval arg=\$$idx      # value of the idx-th argument ($idx is just the index number)

        # If the arg is a SET-type arg...
        if [[ "$arg" =~ [[:alnum:]]${updateOperator}. ]]; then
            # Construct a proto-SET clause using markers to identify the values; "column:=value" becomes "column = @value@,"
            SET_CLAUSE+=" ${arg/${updateOperator}/ = $setClauseMarker}$setClauseMarker,"
            # Parse out the column abbr from the supplied argument
            abbrList+=${arg%${updateOperator}*},
            ((haveSets++))
        else
            retArgs+='"${'$idx'}" '
        fi
    done

    SET_CLAUSE=${SET_CLAUSE%,}
    abbrList=${abbrList%,}

    setReturnValues ${SET_CLAUSE:-$placeholderForEmpty} ${abbrList:-$placeholderForEmpty} $retArgs

    return $haveSets
}

##########################################################################################
# parseOutSelects  command_line...
#
# Given a set of arguments, this function constructs and returns two strings representing
# the pre- and post-selected columns, plus a symbolic list of the remaining (non-selection) arguments
#
# Selection-type arguments can be singletons or comma-separated lists in the following forms:
#    +0 or +00       to clear most or all of the default columns
#    +1columnName    to prepend a column
#    +columnName     to append a column
#  #FUTURE:  ++groupName     to append a column class (the caller needs to expand and append)
#
# Return codes:
#  retCode_ordinarySelection    if selections are detected and no special flags are among them
#  retCode_clearAllSelections   if "00"/clearAll is detected,
#  retCode_selectMainColumnOnly if "0"/clearMost is detected,
#  retCode_noSelection          if no selection arguments are detected
##########################################################################################
function parseOutSelects()
{
    local PRESELECTION_LIST POSTSELECTION_LIST retArgs
    declare -i retCode=$retCode_ordinarySelection

    local zeroInListRegex="(^|,)(00?)($|,)"     # a single or double zero within a comma-separated list
    local groupNameRegex="^\+"              # begins with literal "+".
    local selectionsRegex="(^| )\+"

    # Quickly exit if there are no selection-type args
    if [[ ! "$@" =~ $selectionsRegex ]]; then return 0; fi

    for ((idx=1; idx<=$#; idx++)); do
        eval arg=\$$idx      # value of the idx-th argument ($idx is just the index number)
        eval nextArg=\$$((idx+1))

        isArgOfType "$arg" selection
        if (($?)); then
            # Strip off plus sign
            value=${arg#+}

            # Handle "+0(0)?" / "+ 0(0)?" by setting the clear-defaults flag and erasing the fake zero "column".
            # The caller will then have to clear the default selections since this function cannot access them
            # (If 0 is embedded in a list we will handle it below, within the list)
            if [[ $value =~ ^00?$ || ( $value == "" && "$nextArg" =~ ^00?$ ) ]]; then
                if [[ -z $value ]]; then shift; fi
                : ${value:=$nextArg}
                if [[ $value = "00" ]]; then
                    retCode=$retCode_clearAllSelections
                else
                    retCode=$retCode_selectMainColumnOnly
                fi

            # Handle "+1value" / "+1 value". If the value is or contains a "0" column, remove it and set the return value.
            # In all cases, add whatever remains to the selection list
            elif [[ $value =~ ^1 ]]; then
                value=${value#1}
                if [[ -z $value ]]; then shift; fi
                : ${value:=$nextArg}
                if [[ $value =~ $zeroInListRegex ]]; then
                    retCode=$retCode_selectMainColumnOnly
                    if [[ (${BASH_REMATCH[1]} == ,) && (${BASH_REMATCH[3]} == ,) ]]; then
                        value=${value/${BASH_REMATCH[0]}/,}
                    else
                        value=${value/${BASH_REMATCH[0]}/}
                    fi
                fi
                PRESELECTION_LIST+=$value","

            # Handle "++1value" / "++value"
            elif [[ $value =~ $groupNameRegex ]]; then
                # Leave the remaining plus sign there to tell caller this is a group name
                if [[ ${value:1:0} == 1 ]]; then
                    if [[ -n ${value:2:0} ]]; then
                        PRESELECTION_LIST+=${value/1/},     # Leave + but remove 1
                    else
                        PRESELECTION_LIST+="+"$nextArg","
                        shift
                    fi
                else
                    if [[ -n ${value:1:0} ]]; then
                        POSTSELECTION_LIST+=","$value
                    else
                        POSTSELECTION_LIST+=",+"$nextArg
                        shift
                    fi
                fi

            # Handle "+value" / "+ value". This can include value lists which, if they contain a "0", must be handled
            # by removing the 0 and setting the return value.
            else
                if [[ -z $value ]]; then shift; fi
                : ${value:=$nextArg}
                if [[ $value =~ $zeroInListRegex ]]; then
                    retCode=${#BASH_REMATCH[2]}
                    if [[ (${BASH_REMATCH[1]} == ,) && (${BASH_REMATCH[3]} == ,) ]]; then
                        value=${value/${BASH_REMATCH[0]}/,}
                    else
                        value=${value/${BASH_REMATCH[0]}/}
                    fi
                fi
                POSTSELECTION_LIST+=","$value
            fi

        # The arg is not a selection. Add it to the return list.
        else
            retArgs+='"${'$idx'}" '
        fi

    done

    PRESELECTION_LIST=${PRESELECTION_LIST%,}
    POSTSELECTION_LIST=${POSTSELECTION_LIST#,}

    setReturnValues ${PRESELECTION_LIST:-$placeholderForEmpty} ${POSTSELECTION_LIST:-$placeholderForEmpty} $retArgs

    return $retCode
}

##########################################################################################
# generateWhereClause  [givenWhereParticles ...]
#
# Builds the core WHERE-clause from the supplied arguments. These can be in basic or compound form.
#
# We call the basic-form arguments "NCV (name-comparator-value)" expressions. If the name is
# omitted it will be inferred based on the global settings g_default{Num,Alnum}Cols. If the comparator
# is also omitted it will default to "=". Examples of NCV expressions include:
#
#    n,c,v all present:            column=y   column!=y
#    n omitted:                    <=y   =x,y,z
#    n,c omitted:                  x   x,y,z   x-y
#
# and compound-form arguments are boolean combinations of these.
##########################################################################################
function generateWhereClause()
{
    # Declare return data
    local WHERE_CLAUSE=$placeholderForEmpty
    local valuesToSortBy columnToSortBy

    # Declare helper variables
    declare -i numWheres=0 numDftNumCols=0 numDftAlnumCols=0
    declare -a whereComponent
    local _wheres_bIsList _wheres_bIncludesNull _wheres_bIsRange
    local name nameType code comparator value
    local valueType rhs

    # Array-ify the column name inference rules
    declare -a defaultNumCols defaultAlnumCols dftNumCodes dftAlnumCodes columnNames columnCodes
    OLDFS="$IFS"; IFS=$','
    defaultNumCols=($g_defaultNums)
    dftNumCodes=($g_defaultNumCodes)
    defaultAlnumCols=($g_defaultAlnums)
    dftAlnumCodes=($g_defaultAlnumCodes)
    IFS="$OLDFS"

    # This function receives a sequence of WHERE-clause-like arguments and produces the
    # corresponding WHERE-clause SQL. Each argument takes the form of a boolean combination of
    # NCV expressions. Our plan of attack is to separate them into individual NCVs, call some
    # processing functions on each one, and then link them back together with the right booleans.

    # Set the highest-level conjunction, defaulting to AND.
    isOptionOn 'o|or' $OPTIONS
    if (($?)); then
        g_mainConjunction=OR
    else
        isOptionOn 'a|and' $OPTIONS
        if (($?)); then
            g_mainConjunction=AND
        fi
    fi

    # Handle each argument in turn
    while [[ -n $1 ]]; do

        # Parse and lexically analyze the argument
        parseQueryClause "$1" $TRUE
        getReturnValue rhs

        # Prepare to walk the lexed argument forward
        local sql=" $g_mainConjunction ("   # this outermost '(' ensures the "main" conjunctions have least precedence

        # Break up the argument into its n-c-v predicates. For each predicate, invoke the low-level SQL
        # generators and link the predicates together with the right boolean conjunctions
        while [[ -n $rhs ]]; do
            local ncv ncvType ncvCounter tokenCount nestingLevel

            # Pull the next predicate, boolean, or parenthetical token from the parsed string

            # Front delimiters for predicates
            if [[ $rhs =~ ^${tokenDelimiter}${tt[BEGIN_NCV]}([0-9]+) ]]; then
                ncvCounter=${BASH_REMATCH[1]}
                advanceStream "$rhs" ${BASH_REMATCH[0]}; getReturnValue rhs

                # Retrieve the end delimiter
                [[ $rhs =~ $tokenDelimiter([$g_ncvTypeMarkers])([0-9]+)(.*) ]]
                ncv=${rhs%${BASH_REMATCH[0]}}
                ncvType=${BASH_REMATCH[1]}
                tokenCount=${BASH_REMATCH[2]}
                rhs=${BASH_REMATCH[3]}

                # "Clean up" the predicate. Open with "(" or "NOT (" as appropriate.
                normalizePredicate $ncvType "$ncv"

                # Build the SQL fragment for the current NCV. Choose a builder based on
                # whether the NCV contains an explicit name.
                if [[ $ncvType == ${tt[TYPE_NCV]} ]]; then
                    processNamedNCVArgument
                else
                    processUnnamedNCVArgument
                fi

                sql+=')'   # Needed for complex NCVs like regex lists; superfluous for simple ones
                continue

            # Left grouping parentheses. Since we are at NCV level, there will be no token counter.
            elif [[ $rhs =~ ^$tokenDelimiter${tt[BEGIN_GROUP]}([0-9]+) ]]; then
                sql+="("
                nestingLevel=${BASH_REMATCH[1]}
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue

            # Right grouping parentheses
            elif [[ $rhs =~ ^$tokenDelimiter${tt[END_GROUP]}([0-9]+) ]]; then
                sql+=")"
                nestingLevel=${BASH_REMATCH[1]}
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue

            # Logical operators
            elif [[ $rhs =~ ^${tokenDelimiter}${tt[BOOLEAN]}'&' ]]; then
                sql+=" AND"
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue
            elif [[ $rhs =~ ^${tokenDelimiter}${tt[BOOLEAN]}'|' ]]; then
                sql+=" OR"
                advanceStream "$rhs" "${BASH_REMATCH[0]}"; getReturnValue rhs
                continue

            # space markers
            elif [[ $rhs =~ ^$tokenDelimiter${tt[SPACE]} ]]; then
                sql+=" "
                advanceStream "$rhs" 2; getReturnValue rhs
                continue
            fi

        done

        # Finalize the subclause for this argument
        whereComponent[numWheres++]=$sql")"

        # Get ready to process the next argument
        shift
    done

    # Assemble the WHERE clause from its components
    if ((numWheres > 0)); then
        WHERE_CLAUSE="${whereComponent[@]}"
    fi

    # Pass back all necessary information to the caller
    setReturnValues "$WHERE_CLAUSE" "$columnToSortBy" "$valuesToSortBy"

    return 0
}


########################################################################################################
# normalizePredicate (predicateType, predicate)
# A major subroutine of generateWhereClause() that makes sense of a single name-comparator-value predicate
# and adjusts its components to a uniform, easily-managed format:
#    Expands embedded filenames to the files' content in the form of comma-separated lists
#    Expands abbreviated ranges and prefix lists to full value pairs and lists, respectively
#    Segregates NULLs and sets a special flag for subsequent special handling
#    Factors out negative comparators as NOTs plus the inverse comparators
# This subroutine does not generate any SQL except for a prefix of either "(" or "NOT (" as appropriate.
########################################################################################################
function normalizePredicate()
{
    local msg=""
    local br2
    local predicateType=$1
    local predicate=$2

    ((_wheres_bIsList = FALSE))
    ((_wheres_bIncludesNull = FALSE))
    ((_wheres_bIsRange = FALSE))

    # The input predicate is formatted with delimiters and markup. Here we break it down
    # into name, comparator (defaulting to "=") and value. Only the value is guaranteed to be present.
#TODO Rename name & value to leftSide and rightSide. Careful, they have broad scope.
    [[ $predicate =~ (.*)${tokenDelimiter}[0-9]+${tt[COMPARATOR]}[0-9]+([=\<\!\>]+)(.*) ]]
    if [[ $predicateType == ${tt[TYPE_NCV]} ]]; then
        name=${BASH_REMATCH[1]}
        comparator=${BASH_REMATCH[2]}
        value=${BASH_REMATCH[3]}
            #TODO For now, chop away all markup and delimiters right here so the code below will run as-is
            #TODO on simple NCV inputs. This is of course a stopgap measure that won't work with complex inputs.
            nameType=${name:2:1}    name=${name:3}    # skip the delimiter and count
            valueType=${value:2:1}  value=${value:3}
    else
        comparator='='
        value=${BASH_REMATCH[1]}
            # TODO as just above
            valueType=${value:2:1}  value=${value:3}
    fi

    # If the comparator is negative ('<>' or '!=') then factor out a NOT and invert the comparator
    #TODO Mark this "(" for easy deletion in case it turns out to be superfluous
    isNegativeComparator "$comparator"
    if (($?)); then
        sql+=" NOT ("  # The '(' is needed for e.g. regex lists; is superfluous for simple NCVs
        comparator='='
    else
        sql+=" ("
    fi

    local transformations
    smartExpandExpression "$predicate"; getReturnValues predicate transformations
    applyTransformations "$predicate" "$transformations"

# Eventually:

# Construct the SQL. How we do it depends on the existence and complexity of the left
# and right sides and the types of tokens they contain

# Superseded by the new code above:
#    if [[ $predicateType == ${tt[TYPE_NCV]} ]]; then
#        expandColumnNames "$TABLE_NAMES" "$name"
#        name=${g_returnString%$delim*}      # this is the post-processed (expanded) name
#        code=${g_returnString#*$delim}      # the code tells us how to treat the value
#    fi

#MMMM: One case of a token that needs unraveling:
    # Load file- and stdin-sourced lists into regular list values and set the "is list" indicator
#TODO To get the column name (for stderr), walk the parse tree from the "@@" marker
#    if [[ "$value" =~ $embeddedFileRegex ]]; then
#        ((_wheres_bIsList = TRUE))
#        # If the list is stdin-sourced, prompt the user for the content
#        if [[ "${BASH_REMATCH[0]}" == @@ ]]; then
#            if [[ $predicateType == ${tt[TYPE_NCV]} ]]; then msg="for '$name' "; fi
#            echo '>>> Your values '${msg:-} '(finish with <enter> <ctrl-D>):' > /dev/stderr
#        fi
#        # Load and strip the values. Some extra cleanup is needed that doesn't apply to cmdline lists.
#        loadFileAsCommaList "${BASH_REMATCH[1]:-/dev/stdin}"
#        value=$g_returnString
#    else
#        isArgOfType "$value" list
#        _wheres_bIsList=$?
#    fi

#MMMM Avoid special NULL stuff just yet
#    # If the value includes a NULL marker, set a flag that we will use to treat NULLs in the necessary special way
#    # without "disturbing" ordinary values.
#    if [[ $value =~ (^|,)$NULL_INDICATOR(,|$) ]]; then
#
#        # Set the NULL flag.
#        ((_wheres_bIncludesNull = TRUE))
#
#        # Remove the NULL marker from list-type values, leaving the normal values in place.
#        # (In the case of singleton null markers, we leave them alone to distinguish them from empty arguments.
#        # In all cases we will use the null flag exclusively, disregarding the value, to handle NULLs.)
#        if ((_wheres_bIsList)); then
#            br2=${BASH_REMATCH[2]}
#            if [[ "${BASH_REMATCH[1]}" == , ]]; then br2=; fi
#            value="${value/${BASH_REMATCH[1]}$NULL_INDICATOR$br2/}"
#        fi
#    fi

#MMMM Another case of a token that needs unraveling
#    # In the case of abbreviated value ranges or lists, expand them to complete interval specs or lists
#    isArgOfType "$value" "numRange|dateRange|prefixList"
#    valueType=$?
#    if ((valueType > 0)); then
#
#        # Expand the abbreviated values into complete ones
#        expandValueSet $value $valueType
#        value=$g_returnString
#
#        # Ranges need to be flagged for subsequent conversion to BETWEEN...AND subclauses
#        if ((valueType==1 || valueType==2)); then
#            ((_wheres_bIsRange = TRUE))
#        fi
#    fi

}

########################################################################################################
# processNamedNCVArgument
# A major subroutine of generateWhereClause() that builds a SQL snippet for a name-comparator-value construct
# whose "name" component is explicitly provided
########################################################################################################
function processNamedNCVArgument()
{
    # Turn regex values (singletons or lists) into "LIKE" particles
    isArgOfType "$value" alnumRegex
    if (($?)); then

        # The output: "{AND,OR} [NOT] (x LIKE 'y' OR x LIKE 'z' OR ...)"
        OLDIFS="$IFS"; IFS=","; valueArray=($value)
        for singleVal in ${valueArray[@]}; do
            if [[ $singleVal =~ [%_] ]]; then
                sql+=$name" LIKE '$singleVal' OR "
            else
                sql+=$name" = '$singleVal' OR "
            fi
        done
        IFS="$OLDIFS"

        if ((_wheres_bIncludesNull)); then
            sql+=$name" IS NULL "
        fi

        sql=${sql% OR }

    # Turn lists of values into "IN(...)" particles
    elif ((_wheres_bIsList)); then
        quoteListIfNeeded "$value" $code; getReturnValue value

        # Format lists of floating-point values
        formatValueIfDecimalList "$value"; getReturnValue value

        # To post-sort the result set, we record the values (without quotes) and the column name, always using the FIRST value list we encounter.
        if [[ -z $columnToSortBy ]]; then
            valuesToSortBy=${value//\'/}
            columnToSortBy=$name
        fi

        # Construct the final piece of SQL
        if ((_wheres_bIncludesNull)); then
            sql+="$name IN ($value) OR $name IS NULL"
        else
            sql+="$name IN ($value)"
        fi

    # Turn value ranges (either dates or numbers) into "BETWEEN...AND" particles
    elif ((_wheres_bIsRange)); then
        local lowValue highValue
        quoteRangeValueIfNeeded "$value" $code; getReturnValue value
        formatValueIfDecimal "${value%$delim*}"; getReturnValue lowValue
        formatValueIfDecimal "${value#*$delim}"; getReturnValue highValue

        sql+="$name BETWEEN $lowValue AND $highValue"

    # Turn single values (ints, floats, alnums) into "name = value" particles (or <>, >=, etc.)
    else

        # NULL is a special case of a solitary value...
        if ((_wheres_bIncludesNull)); then
            sql+="$name IS NULL"

        # The general case for solitary values...
        else
            quoteSingleValueIfNeeded "$value" $code; getReturnValue value
            formatValueIfDecimal "$value"; getReturnValue value

            sql+="$name $comparator $value"
        fi
    fi
}

########################################################################################################
# processUnnamedNCVArgument
# A major subroutine of generateWhereClause() that builds a SQL snippet for a name-comparator-value construct
# that lacks an explicit "name" component
########################################################################################################
function processUnnamedNCVArgument()
{
    local singleCol

    # Turn regex values (singletons or lists) into "LIKE" particles
    isArgOfType "$value" alnumRegex
    if (($?)); then

        # Desired output: "{AND,OR} [NOT] (x LIKE 'y' OR x LIKE 'z' OR ...)"
        OLDIFS="$IFS"; IFS=","; valueArray=("$value")
        for singleCol in ${defaultAlnumCols[@]}; do
            local single_col=${singleCol%%:*}
            for singleVal in ${valueArray[@]}; do
                if [[ "$single_col" =~ [%_] ]]; then
                    sql+=$single_col" LIKE '${singleVal}' OR "
                else
                    sql+=$single_col" = '${singleVal}' OR "
                fi
            done
            if ((_wheres_bIncludesNull)); then
                sql+=$single_col" IS NULL OR "
            fi
        done
        IFS="$OLDIFS"

    elif ((_wheres_bIsRange)); then
        # TODO Ranges can be numeric or date ranges, but we only do integer- and alpha-type column inference,
        # so that is all that will work here. Maybe some day we will add default float- and date-type columns.
        for singleCol in ${defaultNumCols[@]}; do
            code=${dftNumCodes[numDftNumCols]}

            quoteRangeValueIfNeeded "$value" $code; getReturnValue value

            local lowValue=${value%$delim*}
            local highValue=${value#*$delim}

            sql+="$singleCol BETWEEN $lowValue AND $highValue OR "
        done

    # Strict alpha or numeric values, no regexes
    else

    # Process numeric values -- singletons and lists
    isArgOfType "$value" "integer|intList|float|floatList|null"
    valueType=$?

    if ((valueType>0)); then

        # Format decimal values and lists of decimal values
        if ((valueType==3)); then
            formatValueIfDecimal "$value"; getReturnValue value
        elif ((valueType==4)); then
            formatValueIfDecimalList "$value"; getReturnValue value
        fi

        # Construct a query fragment piece-by-piece by iterating over the default columns
        for singleCol in ${defaultNumCols[@]}; do
            code=${dftNumCodes[numDftNumCols]}

            # If this column name has length bounds on its values, parse them out
            getValueLengthBounds "$singleCol"
            haveLengthBounds=$?
            getReturnValues singleCol minLength maxLength

            quoteListIfNeeded "$value" $code; getReturnValue fixedValue

            # Add an "OR" atom to this query fragment -- one way for lists, another way for singletons
            if ((_wheres_bIsList)); then

                # Check the values against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkListItemLengths $value $minLength $maxLength; then
                    continue
                fi

                sql+=$singleCol" IN ($fixedValue) OR "
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "
                fi

                # To re-sort the result set, we record the values (without quotes) and the column name, always using the FIRST value list we encounter.
                if [[ -z $columnToSortBy ]]; then
                    valuesToSortBy=${fixedValue//\'/}
                    columnToSortBy=${defaultNumCols[@]//:+([^\ ])/} # space-delimited list of column names
                fi

            else
                # Check the value against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkSingleItemLength $value $minLength $maxLength; then
                    continue
                fi

                # Special case of the NULL as singleton:
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "

                # General case for singletons:
                else
                    sql+=$singleCol" $comparator $fixedValue OR "
                fi
            fi

            ((numDftNumCols++))
        done

    # Process alpha-numeric values -- singletons and lists
    else
    isArgOfType "$value" "alnum|alnumList"
    valueType=$?

    if ((valueType>0)); then

        # Construct a query fragment piece-by-piece by iterating over the default columns
        for singleCol in ${defaultAlnumCols[@]}; do
            code=${dftAlnumCodes[numDftAlnumCols]}

            # If this column name has length bounds on its values, parse them out
            getValueLengthBounds "$singleCol"
            haveLengthBounds=$?
            getReturnValues singleCol minLength maxLength

            # Add an "OR" atom to the current query piece -- one way for lists, another way for singletons
            if ((_wheres_bIsList)); then

                # Check the values against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkListItemLengths $value $minLength $maxLength; then
                    continue
                fi

                # To re-sort the result set, we record the values (without quotes) and the column name, always using the FIRST value list we encounter.
                if [[ -z $columnToSortBy ]]; then
                    valuesToSortBy=$value
                    columnToSortBy=${defaultAlnumCols[@]//:+([^\ ])/} # space-delimited list of column names
                fi

                quoteListIfNeeded "$value" $code; getReturnValue fixedValue

                sql+=$singleCol" IN ($fixedValue) OR "
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "
                fi

            else   # This value is NOT a list.

                # Check the value against the length bounds for the current column, if any.
                if ((haveLengthBounds)) && ! checkSingleItemLength $value $minLength $maxLength; then
                    continue
                fi

                # Special case of the NULL as singleton:
                if ((_wheres_bIncludesNull)); then
                    sql+=$singleCol" IS NULL OR "

                # General case for singletons:
                else
                    quoteSingleValueIfNeeded "$value" $code; getReturnValue fixedValue

                    sql+=$singleCol" $comparator $fixedValue OR "
                fi
            fi

            ((numDftAlnumCols++))
        done

    # Unrecognized value types
    else
        return 2
    fi
    fi
    fi

    sql=${sql% OR }
}

########################################################################################################
# HELPER FUNCTIONS for generateWhereClause and its major subroutines
########################################################################################################

function quoteSingleValueIfNeeded()
{
    local val=$1 code=$2
    if [[ $code =~ ^q ]]; then
        val="'$val'"
    fi
    setReturnValue "$val"
}

function quoteListIfNeeded()
{
    local val=$1 code=$2
    if [[ $code =~ ^q ]]; then
        val="'"${val//,/\',\'}"'"
    fi
    setReturnValue "$val"
}

function quoteRangeValueIfNeeded()
{
    local val=$1 code=$2
    if [[ $code =~ ^q ]]; then
        val="'${val/$delim/'$delim'}'"
    fi
    setReturnValue "$val"
}

# Returns 1 if argument is negative, 0 otherwise
function isNegativeComparator()
{
    [[ $1 == '<>' || $1 == '!=' ]]
    return $((! ($?) ))
}


# Returns 0 if all the list items' lengths are within the bounds, 1 if there is a violation
# Arguments: (1) listBeingChecked  (2) lowerBound  (3) upperBound
function checkListItemLengths()
{
    [[ ($1 =~ (^|,)[^,]{$MIN_VALUE_LEN,$2}(,|$) ) || ($1 =~ [^,]{$(($3+1))} ) ]]
    return $((! $?))
}

# Similar to the above
function checkSingleItemLength()
{
    [[ (${#1} -lt $2) || (${#1} -gt $3) ]]
    return $((! $?))
}

function getValueLengthBounds()
{
    columnName=$1

    # Get the length bounds if they are present
    if [[ $columnName =~ : ]]; then
        haveLengthBounds=1
        [[ $columnName =~ (.*):(.*)-(.*) ]]
        columnName=${BASH_REMATCH[1]}
        minLength=${BASH_REMATCH[2]:-$MIN_VALUE_LEN}
        maxLength=${BASH_REMATCH[3]:-$MAX_VALUE_LEN}
    else
        haveLengthBounds=0
    fi

    setReturnValues "$columnName" "$minLength" "$maxLength"

    return $haveLengthBounds
}

function formatValueIfDecimal()
{
    local val=$1
    isArgOfType "$val" float
    if (($?)); then
        val=${val/#./0.}
    fi

    setReturnValue "$val"
}

function formatValueIfDecimalList()
{
    local val=$1
    isArgOfType "$val" floatList
    if (($?)); then
        val=${val/#./0.}
        val=${val//,./,0.}
    fi

    setReturnValue "$val"
}

############################################################################
# loadFileAsCommaList
# Helper function to read a list of values from a file (or stdin) into a comma-separated list.
# Features some input tolerance smarts: Blank lines are skipped, as are quotes and unprotected spaces.
############################################################################
function loadFileAsCommaList()
{
    fileName=$1
    if [[ ! -e "$fileName" ]]; then
        echo Error: $fileName: File not found.
        exit 7
    fi

    # Load the values
    mapfile -t < "$fileName"
    OLDFS=$IFS; IFS=,

    # Prep/clean the values. At each step, check the value list against a regex first so we can skip the unnecessary steps.

    # (1) single-line and commify the values
    values="${MAPFILE[*]}"
    # (2a) strip unprotected end-spaces
    if [[ "$values" =~ \ , ]]; then values=${values//+( ),/,}; fi
    if [[ "$values" =~ \ $ ]]; then values=${values%%+( )}; fi
    # (2b) strip unprotected begin-spaces
    if [[ "$values" =~ ,\  ]]; then values=${values//,+( )/,}; fi
    if [[ "$values" =~ ^\  ]]; then values=${values##+( )}; fi
    # (3) remove blank entries, which show up as consecutive or extremal commas
    if [[ "$values" =~ ,, ]]; then values=${values//,+(,)/,}; fi
    if [[ "$values" =~ ^, ]]; then values=${values##+(,)}; fi
    if [[ "$values" =~ ,$ ]]; then values=${values%%+(,)}; fi
    # (4) remove quote-protection
    if [[ "$values" =~ [$eitherQuote] ]]; then
        if [[ "$values" =~ [$eitherQuote], ]]; then values=${values//[$eitherQuote],/,}; fi
        if [[ "$values" =~ ,[$eitherQuote] ]]; then values=${values//,[$eitherQuote]/,}; fi
        if [[ "$values" =~ [$eitherQuote]$ ]]; then values=${values%%[$eitherQuote]}; fi
        if [[ "$values" =~ ^[$eitherQuote] ]]; then values=${values##[$eitherQuote]}; fi
    fi
    # Done.
    IFS=$OLDFS

    setReturnValue "$values"
}

############################################################################
# foldResultSet
# Word-wrap a result set to print nicely on the screen and display
# the first (presumably "key") column with each wrapped section
#
# Syntax: foldResultSet  rawResultSet  [selectClause  sortInstructions]
#         where sortInstructions has the form columnsToSortBy:valuesToSortBy
#     and if either side is blank, both bracketed args above are ignored
#
# Assumptions: The string passed in is a result set in tabular format
#     (e.g. mysql's "-t" option) complete with ascii-art boxes. The
#     topmost row is the column header and the rest contain the results.
#
# NOTE: For a truly perfect implementation, the running of the query and
# subsequent management of the result set should be done in perl, which can
# handle arbitrary characters in the data. Here we rely on some simplified
# parsing which does not work on the arbitrary "blob", for instance. Maybe someday
# this will be rewritten in perl.
############################################################################
function foldResultSet()
{
    if [[ -z "$1" ]]; then
        return 0
    fi

    # Be sensitive to the DOS/Unix line-endings discrepancy
    local newLine=$'\n'
    if [[ $1 =~ $'\r'$'\n' ]]; then newLine=$'\r'$'\n'; fi

    # Measure the width of the result set using the ascii-art box that mysql provides.
    # Then parse out the header and body and discard the box
    isOptionOn noHeader $OPTIONS
    if (($?)); then
        [[ $1 =~ (^[+-]+)${newLine}(.*)${newLine}\+ ]]
        resultWidth=${#BASH_REMATCH[1]}
        resultSet=${BASH_REMATCH[2]}
    else
        local plus="\+"
        # Measure the width using the top line of the ascii-art box
        # Use a regex that accepts isolated plus signs in the header
        [[ $1 =~ ^(${plus}[-+]+${plus})${newLine}($'|'.*$'|'${newLine})${plus}[+-]+${newLine}(.*)${newLine}\+ ]]
        resultWidth=${#BASH_REMATCH[1]}
        resultSet=${BASH_REMATCH[2]}${BASH_REMATCH[3]}   # [2] = column hdr   [3] = data rows
    fi

    # Corner case: embedded newlines in result data
    if [[ "$resultSet" =~ [^|+]${newLine} ]]; then   # look for a newline not preceded by the usual characters
        echo "******************************************************" > /dev/stderr
        echo  Embedded newlines detected in result set, cannot fold. > /dev/stderr
        echo "******************************************************" > /dev/stderr
        FOLDED_RESULT="$resultSet"
        echo "${FOLDED_RESULT//|/}"
        return 0
    fi

    # Before folding, pre-sort the result set if a sort is needed
    # TODO Work in progress...
    if [[ "$3" =~ ^[a-z] ]]; then
        :
    fi

#    local foldedWidth=$((COLUMNS-KEY_WIDTH))
#    if ((foldedWidth < 1)); then
    if ((resultWidth < COLUMNS)); then
        # No folding needed, the result is narrow enough for the screen
        # TODO If we've monkeyed with the column ordering of the result set for the reasons below, we need to clean up the monkeying before setting FOLDED_RESULT here.
        FOLDED_RESULT="$resultSet"
        echo "${FOLDED_RESULT//|/}"
        return 0
    else

        # Determine the width of the "key" column.
        # TODO This function currently assumes the key column is the first column. Change this function and its caller(s)
        # TODO so that this becomes a universally valid assumption, i.e. reorder the select clause before running the query!
        [[ "$resultSet" =~ ^(\|[^|]*)\ \| ]]
        local KEY_HDR=${BASH_REMATCH[1]}
        KEY_START=1   # TODO figure this out for the general case.
        local KEY_WIDTH=${#KEY_HDR}
        ((KEY_WIDTH++))

        # Chop off the key column. FIXME: Currently assumes it's the first even though that isn't always the case.
        characterCounter=""
        for i in {1..10}; do
            characterCounter+="????????????????????"
        done
        FOLDED_RESULT=$'\n'$resultSet
        FOLDED_RESULT=${FOLDED_RESULT//$'\n'${characterCounter:1:$KEY_WIDTH}/$'\n'}

        # Fold the rest of the result string: (1) hide the spaces and change pipes to spaces so we can fold easily, (2) fold, and (3) reset the spaces and pipes.
        # It was determined experimentally that this method involving two "tr" calls is much faster
        # for medium-to-large result sets than using two pairs of bash-builtin search-and-replacement operations.

        FOLDED_RESULT=$(echo "$FOLDED_RESULT" | tr ' |' '| ' | fold -sw $((COLUMNS-KEY_WIDTH)) | tr '| ' ' |')

        # Useful recipe for a generic right-hand-side cut. You need to supply the field width; note the "${}":
        #printf -v FOLDED_RESULT "%${}s\n" ${FOLDED_RESULT//$'\n'${characterCounter:1:$KEY_WIDTH}/$'\n'}

        # TODO Eventually we should address the problem of the key column not always being the first column.
        # TODO In that case, assuming we want to fold in the first place (we can make that optional with a user option "dontFold | raw | <etc.>")
        # TODO its probably best to pre-adjust the SELECT_CLAUSE before invoking the db engine to get a resultSet that's as easy as possible to manipulate, and
        # TODO then tweak it to the intended result. That's because to do all the manipulation right here is pretty tricky if the key column is sitting in the middle
        # TODO and we want to leave it in place on the first folded chunk of results (if it fits there) while displaying it **first** on the subsequent folded chunks.
        # TODO So let's propose a scheme where we've pre-adjusted it by putting the key column first and some placeholder in the key column's user-intended position.
        # TODO Meanwhile, we'll retain our use of two row-major arrays, one for the key column and one for the rest of the result set, so the for-loop
        # TODO that prints everything can print as follows, line-by-line:    ${left side of main block} ${key block} ${right side of main block}.
        # TODO All we have to do is compensate for the placeholder in the main block by deleting the spaces and one of the field separators around it.

    fi

    # Array-ify
    declare -a FOLDED_ARR
    declare -a KEY_ARR
    OLDFS="$IFS"; IFS=$'\n'
    FOLDED_ARR=($FOLDED_RESULT)
    KEY_ARR=($(cut -c2-$KEY_WIDTH <<< "$resultSet"))  # TODO instead of cut, use a ${foo//???????/} construction (i.e. delete chars)
    local numFoldedLines="${#FOLDED_ARR[@]}"
    IFS="$OLDFS"

    # Print the contents in the right order (not the given order)
    local phaseShift currentLine
    local numRawLines=$(echo "${resultSet:$KEY_WIDTH}" | wc -l) # TODO instead of wc -l, use countChars($'\n')
    local numSections=$((numFoldedLines / numRawLines))

    # Proceed section by section
    for ((phaseShift=0; phaseShift<$numSections; phaseShift++)); do

        # Print key header and column header
        echo "${KEY_ARR[0]}""${FOLDED_ARR[$phaseShift]//|/}"

        # Print all following key rows and result rows plus a blank line
        currentLine=$phaseShift
        for ((lineIdx=1; lineIdx<$numRawLines; lineIdx++)); do
            ((currentLine+=numSections))
            echo "${KEY_ARR[lineIdx]}""${FOLDED_ARR[$currentLine]//|/}"
        done
        echo
    done

    # Return the "key column" as a single row vector
    # echo ${KEY_ARR[@]}
}


############################################################################
# Minor routines
############################################################################
validate_single_column()
{
    if [ $# -lt 1 ]; then
        echo USAGE:  ${FUNCNAME[0]}  columnNameRegex
        exit 12
    fi
}

validate_id_or_name_regex()
{
    if [ $# -lt 1 ]; then
        echo USAGE:  ${FUNCNAME[0]}  id_or_nameRegex
        exit 34
    fi
}



